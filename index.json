[{"categories":["Linux"],"content":"参考：Shell教程|菜鸟教程 shell 环境 #!/bin/bash：脚本第一行，告诉系统使用什么解释器来执行，即使用哪一个 shell ","date":"2024-12-07","objectID":"/02b965210d21/:0:0","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"注释 单行注释用# 多行注释用 :\u003c\u003c 开头，! 包裹注释内容 # 这是一个单行注释 :\u003c\u003c! 这是多行注释 这是多行注释 这是多行注释 ! ","date":"2024-12-07","objectID":"/02b965210d21/:1:0","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"变量 # 变量 = 号两侧不能有空格，大小写敏感 my_name=\"lanhuli\" echo ${my_name} unset my_name # 删除变量 双引号和单引号的区别 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 双引号里可以有变量 双引号里可以出现转义字符 只读变量 myUrl=\"https://www.google.com\" readonly myUrl myUrl=\"https://www.runoob.com\" # 执行报错，NAME: This variable is read only. 字符串变量 #!/bin/bash name=\"Shell\" url=\"http://1.1.1.1/\" # 拼接字符串 str1=\"${url}${name}\" str2=${url}${name} # 中间不能有空格 str3=\"${url}：${name}\" # 中间可以出现其它字符，包括空格 ######### 输出 ######## http://1.1.1.1/Shell http://1.1.1.1/Shell http://1.1.1.1/：Shell 获取字符串长度 string=\"abcdefg\" echo ${#string} # 变量为字符串时，${#string} 等价于 ${#string[0]} echo ${#string[0]} echo ${string:1:4} # 字符串第 2 个字符开始截取 4 个字符 整型变量 ","date":"2024-12-07","objectID":"/02b965210d21/:2:0","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"运算符 ","date":"2024-12-07","objectID":"/02b965210d21/:3:0","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 假定变量 a 为 10，变量 b 为 20： ","date":"2024-12-07","objectID":"/02b965210d21/:3:1","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"字符串运算符 假定变量 a 为 “abc”，变量 b 为 “efg”： ","date":"2024-12-07","objectID":"/02b965210d21/:3:2","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"数组 # 创建数组 my_array=(A B \"C\" D) echo \"第一个元素为: ${my_array[0]}\" echo \"第二个元素为: ${my_array[1]}\" echo \"第三个元素为: ${my_array[2]}\" echo \"第四个元素为: ${my_array[3]}\" 关联数组 declare -A array_name # 创建关联数组 declare -A site site[\"google\"]=\"www.google.com\" site[\"runoob\"]=\"www.runoob.com\" site[\"taobao\"]=\"www.taobao.com\" echo ${site[\"runoob\"]} 获取数组中所有的元素 declare -A site site[\"google\"]=\"www.google.com\" site[\"runoob\"]=\"www.runoob.com\" site[\"taobao\"]=\"www.taobao.com\" echo \"数组的键为: ${!site[*]}\" echo \"数组的键为: ${!site[@]}\" 获取数组的长度 my_array[0]=A my_array[1]=B my_array[2]=C my_array[3]=D echo \"数组元素个数为: ${#my_array[*]}\" echo \"数组元素个数为: ${#my_array[@]}\" ","date":"2024-12-07","objectID":"/02b965210d21/:4:0","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"流程控制 ","date":"2024-12-07","objectID":"/02b965210d21/:5:0","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"if分支语句 a=10 b=20 if [ $a == $b ] then echo \"a 等于 b\" else echo \"a 不等于 b\" fi 注意：如果 else 分支没有语句执行，就不要写这个 else。 多分支语句 a=10 b=20 if [ $a == $b ] then echo \"a 等于 b\" elif [ $a -gt $b ] then echo \"a 大于 b\" elif [ $a -lt $b ] then echo \"a 小于 b\" else echo \"没有符合的条件\" fi ","date":"2024-12-07","objectID":"/02b965210d21/:5:1","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"for 循环 ","date":"2024-12-07","objectID":"/02b965210d21/:5:2","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"while 循环 #!/bin/bash num=2 while ((num\u003c100)) #数值与运算符可以没有空格,变量的使用时也可以不使用$num do echo \"$num\" ((num=num*2)) done ","date":"2024-12-07","objectID":"/02b965210d21/:5:3","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"shell 脚本例子 ","date":"2024-12-07","objectID":"/02b965210d21/:6:0","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"安装 docker 脚本 从自己的服务器下载 docker 离线安装包 #!/bin/bash url=\"url\" docker_version=\"docker-23.0.6.tgz\" docker_compose_version=\"docker-compose-2.17.0\" # 判断网络环境，优先内网 echo \"正在检测网络环境,请稍等...\" ping 192.168.0.211 -c 3 \u0026\u003e /dev/null if [ $? -eq 0 ] then echo \"检测到网络环境可通内网\" url=\"http://192.168.0.211/\" else # 内网不通，检测外网 ping oss.lanhuli.top -c 3 \u0026\u003e /dev/null if [ $? -eq 0 ] then echo \"检测到网络环境可通外网\" url=\"http://oss.lanhuli.top/\" fi fi # 安装docker echo \"正在下载docker安装包,请稍等...\" wget ${url}${docker_version} \u0026\u003e /dev/null if [ $? -eq 0 ] then echo ${docker_version}\"安装包下载成功\" else echo ${docker_version}\"安装包下载失败\" fi tar -xf ${docker_version} chmod 755 ./docker/* cp ./docker/* /usr/bin/ rm -rf docker rm -rf ${docker_version} echo \"docker安装完毕\" echo \"docker版本：\"`docker -v` # 安装docker-compose echo \"正在下载docker-compose\" wget ${url}${docker_compose_version} \u0026\u003e /dev/null if [ $? -eq 0 ] then echo ${docker_compose_version}\"下载成功\" else echo ${docker_compose_version}\"下载失败\" fi chmod 755 ${docker_compose_version} mv ${docker_compose_version} /usr/local/bin/docker-compose echo \"docker-compose安装完毕\" echo \"docker-compose版本：\"`docker-compose -v` # 将 docker 注册成系统服务 touch /etc/systemd/system/docker.service cat \u003e /etc/systemd/system/docker.service\u003c\u003c EOF [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/bin/dockerd ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=infinity LimitNPROC=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target EOF chmod +x /etc/systemd/system/docker.service systemctl daemon-reload echo \"注册完毕，可以使用systemctl命令启动docker\" ","date":"2024-12-07","objectID":"/02b965210d21/:6:1","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"安装 frp 脚本 #!/bin/bash # wget http://oss.lanhuli.top/frp_0.60.0_linux_amd64.tar.gz wget http://192.168.0.211/frp_0.60.0_linux_amd64.tar.gz tar -xzf frp_0.60.0_linux_amd64.tar.gz cat \u003e frp_0.60.0_linux_amd64/frps.toml \u003c\u003c EOF bindPort = 16669 auth.token = \"xujiajun#7732.\" EOF mv frp_0.60.0_linux_amd64 /opt/frp_0.60.0_linux_amd64 rm frp_0.60.0_linux_amd64.tar.gz # 注册成系统服务 touch /etc/systemd/system/frps.service cat \u003e /etc/systemd/system/frps.service\u003c\u003c EOF [Unit] # 服务名称，可自定义 Description = frp server After = network.target syslog.target Wants = network.target [Service] Type = simple # 启动 frps 的命令，需修改为您的 frps 的安装路径 ExecStart = /opt/frp_0.60.0_linux_amd64/frps -c /opt/frp_0.60.0_linux_amd64/frps.toml [Install] WantedBy = multi-user.target EOF chmod +x /etc/systemd/system/frps.service systemctl daemon-reload ","date":"2024-12-07","objectID":"/02b965210d21/:6:2","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"监控服务是否挂掉并自动重新启动 脚本主要负责查询服务是否运行，没有运行的话就启动服务。然后将这个脚本通过 crontab 定时任务每分钟运行一次 #!/bin/bash # 检测服务是否运行 result=`systemctl status nginx | grep \"active (running)\"` #echo ${result} if [[ \"$result\" != \"\" ]] then echo \"nginx已启动\" else echo \"nginx未启动，立即启动nginx\" systemctl restart nginx fi 上述脚本逻辑：通过 systemctl 命令查看 nginx 的运行状态，如果是启动状态，就会有关键词 active (running) 在其中，result 就不为空，通过这个来判断 nginx 是启动还是关闭状态。如果 result 为空，说明 nginx 停了，可以使用 systemctl start nginx 命令重新启动 nginx。 把脚本通过 crontab 定时任务每隔 1 分钟运行检查一次，就可以达到目的。输入 crontab -e 命令，在文件末尾添加 */1 * * * * /root/start_nginx.sh 然后保存 注意：不一定非要使用 systemctl status nginx | grep \"active (running)\" 进行判断，也可以使用 ps 命令查看是否存在进程。 #!/bin/bash # 检测frpc是否运行 if [[ `systemctl status frps | grep \"active (running)\"` = \"\" ]];then systemctl start frps;fi # 需要将 frps 注册为 systemd 服务 ","date":"2024-12-07","objectID":"/02b965210d21/:6:3","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"其它小知识 ","date":"2024-12-07","objectID":"/02b965210d21/:7:0","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"关于双小括号使用 参考： https://blog.csdn.net/u011479200/article/details/79603385 a=10 b=20 if (( $a == $b )) then echo \"a 等于 b\" elif (( $a \u003e $b )) then echo \"a 大于 b\" elif (( $a \u003c $b )) then echo \"a 小于 b\" else echo \"没有符合的条件\" fi 用[] a=10 b=20 if [ $a == $b ] then echo \"a 等于 b\" elif [ $a -gt $b ] then echo \"a 大于 b\" elif [ $a -lt $b ] then echo \"a 小于 b\" else echo \"没有符合的条件\" fi ","date":"2024-12-07","objectID":"/02b965210d21/:7:1","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"关于 == 、=和-eq 在 shell 中，=和 == 运算符都可以用于判断两个字符串、两个字符串变量是否相同，== 支持模式匹配，而= 不支持模式匹配。使用 -eq 来判断两个整数是否相等。 ","date":"2024-12-07","objectID":"/02b965210d21/:7:2","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["Linux"],"content":"判断命令是否执行成功 # shell中使用符号“$?”来显示上一条命令执行的返回值，如果为0则代表执行成功，其他表示失败。 ping 192.168.0.110 -c 3 \u0026\u003e/dev/null if [ $? -eq 0 ] then echo \"能ping通\" else echo \"不能ping通\" fi ","date":"2024-12-07","objectID":"/02b965210d21/:7:3","tags":["shell脚本"],"title":"Shell脚本编程","uri":"/02b965210d21/"},{"categories":["华为交换机"],"content":"简单命令 undo shutdown //激活接口 display current-configuration // 查看当前的配置（内存中） display saved-configuration // 查看保存的配置（Flash 中） 端口信息查看 信息含义： https://support.huawei.com/enterprise/zh/doc/EDOC1100064380/e51dee46 光模块查看 参考： https://support.huawei.com/enterprise/zh/doc/EDOC1100127136/94ef2802 端口批量操作 端口批量修改为 access 参考： https://support.huawei.com/enterprise/zh/knowledge/EKB1000029447 **配置临时端口组** # 配置接口GE1/0/9至GE1/0/15加入到临时端口组(使用port-group group-member命令)。 \u003cHUAWEI\u003e system-view [HUAWEI] port-group group-member gigabitethernet 1/0/9 to gigabitethernet 1/0/15 [HUAWEI-port-group] **配置永久端口组** # 配置接口GE1/0/1至GE1/0/8加入到永久端口组portgroup1（使用port-group命令）。 \u003cHUAWEI\u003e system-view [HUAWEI] port-group portgroup1 [HUAWEI-port-group-portgroup1] group-member gigabitethernet 1/0/1 to gigabitethernet 1/0/8 在VLAN视图下批量将接口加入VLAN \u003cHUAWEI\u003e system-view [HUAWEI] vlan 10 [HUAWEI-vlan10] port gigabitethernet 0/0/1 to 0/0/5 mac 黑洞 display mac-address blackhole info-center source ds channel 0 log state off trap state offdhcp vlan 1 是默认的 vlan，开机后所有的接口都属于 vlan 1 交换机的三种接口模式：access、trunk 交换机之间 trunk 连接 四台 PC 配置好 IP 地址即可 两台交换机配置 # LSW1和LWS2相同 [Huawei]vlan batch 10 20 # 创建vlan [Huawei]int g 0/0/3 [Huawei-GigabitEthernet0/0/3]port link-type trunk [Huawei-GigabitEthernet0/0/3]port trunk allow-pass vlan all [Huawei-GigabitEthernet0/0/3]int g 0/0/1 [Huawei-GigabitEthernet0/0/1]port link-type access # 将端口类型设置为access [Huawei-GigabitEthernet0/0/1]port default vlan 10 # 端口加入到vlan 10 [Huawei-GigabitEthernet0/0/1]int g 0/0/2 [Huawei-GigabitEthernet0/0/2]port link-type access [Huawei-GigabitEthernet0/0/2]port default vlan 20 PC 1 和 PC 3 可以互通，PC 2 和 PC 4 可以互通，但是 1 和 2 不通，3 和 4 不通，因为它们是不同网段。 简单的三层交换网络 两台 PC 配置好 IP 地址和网关 两台交换机配置 # LSW1 [Huawei]vlan batch 10 20 # 创建两个vlan [Huawei]interface GigabitEthernet 0/0/1 [Huawei-GigabitEthernet0/0/1]port link-type access # 将端口类型设置为access [Huawei-GigabitEthernet0/0/1]port default vlan 10 # 端口加入到vlan 10 [Huawei-GigabitEthernet0/0/1]int g 0/0/2 [Huawei-GigabitEthernet0/0/2]port link-type access [Huawei-GigabitEthernet0/0/2]port default vlan 20 [Huawei-GigabitEthernet0/0/2]int g 0/0/3 [Huawei-GigabitEthernet0/0/3]port link-type trunk # 将端口类型设置为trunk [Huawei-GigabitEthernet0/0/3]port trunk allow-pass vlan all # 允许所有的vlan数据通过 # LSW2 [Huawei]vlan batch 10 20 [Huawei]interface vlan 10 [Huawei-Vlanif10]ip address 1.1.1.254 255.255.255.0 # 配置网关 [Huawei-Vlanif10]int vlan 20 [Huawei-Vlanif20]ip add 1.1.2.254 255.255.255.0 [Huawei-Vlanif20]int g 0/0/1 [Huawei-GigabitEthernet0/0/1]port link-type trunk [Huawei-GigabitEthernet0/0/1]port trunk allow-pass vlan all 配置好后，两台 PC 之间可以 ping 通。 单臂路由 nat telnet 配置 stp 二层环路带来的问题 广播风暴和 mac 地址漂移 二层环路和三层环路 ","date":"2024-10-17","objectID":"/36371b0398bc/:1:0","tags":["华为交换机"],"title":"华为交换机命令","uri":"/36371b0398bc/"},{"categories":["华为交换机"],"content":"rip 路由协议 https://support.huawei.com/enterprise/zh/doc/EDOC1100198525/217b4f86 https://blog.csdn.net/qq_44933518/article/details/109491203 ","date":"2024-10-17","objectID":"/36371b0398bc/:2:0","tags":["华为交换机"],"title":"华为交换机命令","uri":"/36371b0398bc/"},{"categories":["华为交换机"],"content":"链路聚合 链路聚合分为手工负载分担模式、静态 LACP 模式和动态 LACP 模式。 LACP 静态和动态的区别：用户权限不同。动态 lacp 汇聚是一种系统自动创建/删除的汇聚，不允许用户增加或删除动态 lacp 汇聚中的成员端口。静态 lacp 汇聚由用户手工配置，不允许系统自动添加或删除汇聚组中的端口。汇聚组中必须至少包含一个端口。当汇聚组只有一个端口时，只能通过删除汇聚组的方式将该端口从汇聚组中删除。 链路聚合应用场景：交换机之间，用来提升带宽和可靠性；交换机和服务器之间，提高服务器的接入带宽和可靠性；交换机与堆叠系统；防火墙双击热备。 ","date":"2024-10-17","objectID":"/36371b0398bc/:3:0","tags":["华为交换机"],"title":"华为交换机命令","uri":"/36371b0398bc/"},{"categories":["华为交换机"],"content":"手工链路聚合 # LSW1和LSW2都是相同的配置方法 [Huawei]interface Eth-Trunk 1 # 创建链路聚合组 [Huawei-Eth-Trunk1]q [Huawei]interface g 0/0/1 [Huawei-GigabitEthernet0/0/1]eth-trunk 1 # 将接口1加入聚合组 Info: This operation may take a few seconds. Please wait for a moment...done. [Huawei-GigabitEthernet0/0/1] Mar 19 2024 16:19:52-08:00 Huawei %%01IFNET/4/IF_STATE(l)[0]:Interface Eth-Trunk 1 has turned into UP state. [Huawei-GigabitEthernet0/0/1]q [Huawei]int g 0/0/2 [Huawei-GigabitEthernet0/0/2]eth-trunk 1 # 将接口2加入聚合组 # 创建个vlan [Huawei]vlan 10 [Huawei-vlan10]q [Huawei]interface Vlanif 10 [Huawei-Vlanif10]ip add 1.1.1.2 24 [Huawei-Vlanif10]q [Huawei]int Eth-Trunk 1 [Huawei-Eth-Trunk1]port link-type access # 将Eth-Trunk 1接口设置为access [Huawei-Eth-Trunk1]port default vlan 10 在 LSW 1 上 ping 1.1.1.2 可以通 手工配置的问题： 1）成员接口一定不能配错 2）交换机无法得知对端交换机的端口是否运行正常 ","date":"2024-10-17","objectID":"/36371b0398bc/:3:1","tags":["华为交换机"],"title":"华为交换机命令","uri":"/36371b0398bc/"},{"categories":["华为交换机"],"content":"LACP 静态链路聚合 配置系统优先级是为了区别本端设备与对端设备优先级的高低，系统优先级高的将被选作链路聚合组的主动端，按照主动端设备的接口来选择活动接口。配置接口优先级是为了区别同一设备不同接口的优先级，接口优先级高的将被选作活动接口。如果 Eth-Trunk 两端设备都没有配置系统优先级，两端系统优先级都是缺省值 32768，此时需要按照系统 MAC 来选择主动端，系统 MAC 小的优先。当手工加入链路组的接口数超过了该阈值的限制，就需要选择哪些接口为活动接口，而设置接口 LACP 优先级即可保证在静态模式下高优先级的接口成为活动接口。 交换机的 1、2、3 端口做聚合使用，其中有一条做备用 # LSW1的配置 [Huawei]int Eth-Trunk 1 [Huawei-Eth-Trunk1]mode lacp # 配置Eth-Trunk的工作模式。缺省情况下，Eth-Trunk的工作模式为手工模式。 [Huawei-Eth-Trunk1]trunkport GigabitEthernet 0/0/1 to 0/0/3 # 在Eth-Trunk接口视图下向聚合组中加入成员接口 Info: This operation may take a few seconds. Please wait for a moment...done. [Huawei-Eth-Trunk1] Mar 19 2024 19:12:29-08:00 Huawei %%01IFNET/4/IF_STATE(l)[0]:Interface Vlanif1 h as turned into DOWN state. Mar 19 2024 19:12:29-08:00 Huawei %%01IFNET/4/IF_STATE(l)[1]:Interface Vlanif1 h as turned into UP state. Mar 19 2024 19:12:29-08:00 Huawei %%01IFNET/4/IF_STATE(l)[2]:Interface Eth-Trunk 1 has turned into UP state. [Huawei-Eth-Trunk1]max active-linknumber 2 # 配置链路聚合组活动接口数目的上限阈值为2。另一条做备用 [Huawei-Eth-Trunk1]port link-type trunk [Huawei-Eth-Trunk1]port trunk allow-pass vlan all [Huawei-Eth-Trunk1]q [Huawei]lacp priority 30000 # LACP优先级值。取值越小LACP优先级越高。 [Huawei]vlan 10 [Huawei-vlan10]q [Huawei]int g 0/0/11 [Huawei-GigabitEthernet0/0/11]port link-type access [Huawei-GigabitEthernet0/0/11]port default vlan 10 注意 LSW 1 设置 lacp 的优先级 # LSW2的配置 [Huawei]int Eth-Trunk 1 [Huawei-Eth-Trunk1]mode lacp [Huawei-Eth-Trunk1]trunkport GigabitEthernet 0/0/1 to 0/0/3 Info: This operation may take a few seconds. Please wait for a moment...done. [Huawei-Eth-Trunk1] Mar 19 2024 19:12:29-08:00 Huawei %%01IFNET/4/IF_STATE(l)[0]:Interface Vlanif1 h as turned into DOWN state. Mar 19 2024 19:12:29-08:00 Huawei %%01IFNET/4/IF_STATE(l)[1]:Interface Vlanif1 h as turned into UP state. Mar 19 2024 19:12:29-08:00 Huawei %%01IFNET/4/IF_STATE(l)[2]:Interface Eth-Trunk 1 has turned into UP state. [Huawei-Eth-Trunk1]max active-linknumber 2 [Huawei-Eth-Trunk1]port link-type trunk [Huawei-Eth-Trunk1]port trunk allow-pass vlan all [Huawei-Eth-Trunk1]q [Huawei]vlan 10 [Huawei-vlan10]q [Huawei]int GigabitEthernet 0/0/11 [Huawei-GigabitEthernet0/0/11]port link-type access [Huawei-GigabitEthernet0/0/11]port default vlan 10 两台 PC 可以互通 300 台设备同网段相连 假如有 300 台设备需要互相连接，ip 地址划分于 192.168.201.1 - 192.168.202.254 之间。所有设备必须在这个地址段里面，一般可以通过划分 vlan 的方式进行连接，但是有些情况下可以使用子网掩码进行划分连接。 24 位的子网掩码可用的地址为 254 个，无法满足需求。23 位的子网掩码可用的地址为 510 个，但是其网络地址在 192.168.200.1 - 192.168.201.254 之间，无法满足我们 202 段的地址。 所以使用 22 位的子网掩码可用的地址为 1022 个，并且地址段在 192.168.200.1 - 192.168.203.254 之间，满足我们 201 和 202 段的地址。 实际网络拓扑图 其中三台交换机不用进行任何配置，只需要把设备的 ip 地址配置好即可，其中注意子网掩码为 255.255.252.0，这样所有的设备均可互通了。 补充：实际上还需要在交换机上配置一个 vlan，将所有的设备加入到这个 vlan 当中，以便访问其它网络。这里没有配置，是因为华为交换机有个默认的 vlan 1，所有端口默认均属于 vlan 1 当中，省去 vlan 的创建；交换机之间不用设置 trunk，是因为三台交换机属于同一个 vlan，同一个 vlan 之间通信可以不用设置为 trunk（华为交换机端口模式默认为 hybrid，这个模式可以实现 trunk，但是二者有点区别） 进行 vlan 配置 ","date":"2024-10-17","objectID":"/36371b0398bc/:3:2","tags":["华为交换机"],"title":"华为交换机命令","uri":"/36371b0398bc/"},{"categories":["华为交换机"],"content":"端口批量操作 临时加入端口组，退出临时端口组后，该临时端口组被系统自动删除。 \u003cHUAWEI\u003e system-view [HUAWEI] port-group group-member gigabitethernet 0/0/1 to gigabitethernet 0/0/3 [HUAWEI-port-group]参考： https://support.huawei.com/enterprise/zh/doc/EDOC1100156648/dd6c63c5 端口批量加入 vlan \u003cHUAWEI\u003e system-view [HUAWEI] port-group pg1 [HUAWEI-port-group-pg1] group-member gigabitethernet0/0/1 to gigabitethernet0/0/5 [HUAWEI-port-group-pg1] port link-type access [HUAWEI-port-group-pg1] port default vlan 10参考： https://support.huawei.com/enterprise/zh/doc/EDOC1000178154/13b58ade ","date":"2024-10-17","objectID":"/36371b0398bc/:4:0","tags":["华为交换机"],"title":"华为交换机命令","uri":"/36371b0398bc/"},{"categories":["华为交换机"],"content":"配置 telnet 远程登录 参考文章： https://support.huawei.com/enterprise/zh/doc/EDOC1100365047/b3180b88 ensp 放置一台 AR1220 路由器和 cloud。配置 cloud，使用 vmware net 8 网卡，其它网卡也一样。 首先配置路由器 ip 地址：192.168.204.100。地址要和网卡属于同一网段 \u003cHuawei\u003esys Enter system view, return user view with Ctrl+Z. [Huawei]int [Huawei]interface g [Huawei]interface GigabitEthernet 0/0/0 [Huawei-GigabitEthernet0/0/0]ip ad [Huawei-GigabitEthernet0/0/0]ip address 192.168.204.100 255.255.255.0 Oct 13 2024 08:48:26-08:00 Huawei %%01IFNET/4/LINK_STATE(l)[0]:The line protocol IP on the interface GigabitEthernet0/0/0 has entered the UP state. [Huawei-GigabitEthernet0/0/0]q [Huawei]q \u003cHuawei\u003esave The current configuration will be written to the device. Are you sure to continue? (y/n)[n]:y It will take several minutes to save configuration file, please wait........ Configuration file had been saved successfully Note: The configuration file will take effect after being activated \u003cHuawei\u003eping 192.168.240.1 用宿主机 ping 路由器应该也是能通的，就没问题。 其次设置路由器 telnet 远程登录 1、路由器开启 Telnet 服务（系统视图） [Huawei]display telnet server status # 查看telnet服务状态，是否开启 [Huawei]telnet server enable # 启动telnet服务 [Huawei]undo telnet server enable # 关闭telnet服务 2、配置 VTY 用户用户的界面权限 # 配置VTY用户界面的最大个数（同时可以登录的最大数） [Huawei]user-interface maximum-vty 15 # 配置VTY用户界面的最大个数（同时可以登录的最大数）默认是5，这个可以不设置 # 配置VTY用户界面的终端属性 [Huawei]user-interface vty 0 14 #上面是15所有这里是0 14 如果选择默认这里是0 4 [Huawei-ui-vty0-14]protocol inbound telnet #配置vty支持telnet协议 # 配置VTY用户界面的用户验证方式 [Huawei-ui-vty0-14]authentication-mode aaa #配置用户终端的身份验证模式为aaa认证为aaa认证 [Huawei-ui-vty0-14]quit #退出vty配置界面 3、配置 VTY 用户界面的认证方式和用户级别 # 配置VTY用户界面的认证方式为AAA [Huawei]aaa #进入aaa配置模式 [Huawei-aaa]local-user route password ? #推荐用irreversible-cipher，对用户密码采用不可逆算法进行了加密 [Huawei-aaa]local-user route password irreversible-cipher route123 # 创建账号：route 密码：route123 [HUAWEI-aaa]local-user route service-type telnet # 配置本地用户 route 的接入类型为Telnet方式 [HUAWEI-aaa]local-user route privilege level 15 # 配置本地用户 route 的级别为15 [HUAWEI-aaa]q 上述配置完成后，即可通过 telnet 进行远程登录。 关于用户的认证方式：AAA、Password、None AAA 认证：需要输入用户名和密码。（推荐使用） password 认证：只需要输入密码。 None 无认证：不需要输入任何有关账户的信息 关于用户密码的选择模式：simple、cipher、irreversible-cipher simple：密码显示为明文。 cipher：对用户口令采用可逆算法进行了加密，非法用户可以通过对应的解密算法解密密文后得到明文密码，安全性较低。 irreversible-cipher：表示对用户密码采用不可逆算法进行了加密，使非法用户无法通过解密算法特殊处理后得到明文密码，为用户提供更好的安全保障。（推荐使用） ","date":"2024-10-17","objectID":"/36371b0398bc/:5:0","tags":["华为交换机"],"title":"华为交换机命令","uri":"/36371b0398bc/"},{"categories":["华为交换机"],"content":"配置 ssh 远程登录 过程和配置 telnet 差不多 [S1]int vlanif1 ip add 192.168.245.254 24 //配置远程管理地址 [S1]aaa local-user root password cipher zhaoge-hyz //创建远程账户、密码 [S1-aaa]local-user root service-type ssh //为用户开启SSH服务 [S1-aaa]local-user root privilege level 3 //设置权限等级 [S1]rsa local-key-pair create //创建本地密钥对 [S1]stelnet server enable //启用Stenlnet服务 [S1]ssh authentication-type default password [S1]user-interface vty 0 4 //配置VTY界面，AAA认证，SSH方式接入 [S1-ui-vty0-4]authentication-mode aaa [S1-ui-vty0-4]protocol inbound ssh ","date":"2024-10-17","objectID":"/36371b0398bc/:6:0","tags":["华为交换机"],"title":"华为交换机命令","uri":"/36371b0398bc/"},{"categories":["Linux"],"content":"环境变量相关的配置文件 /etc/profile：此文件为系统的每个用户设置环境信息。 /etc/bashrc或 /etc/bash.bashrc：为每一个运行 bash shell 的用户执行此文件.当 bash shell 被打开时,该文件被读取。 ~/.bashrc：该文件包含专用于你的 bash shell 的 bash 信息,当登录时以及每次打开新的 shell 时,该文件被读取。 ~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人配置，需要修改自己的数据，就写入这些文件！（ps1：其实 bash 的 login shell 配置只会读取上面三个文件的其中一个，而读取的顺序则是依照上面的顺序。ps2：这三个文件一般没啥人修改的，因为它们最终都是去调用读取~/.bashrc 这个文件。ps3：这三个文件不一定存在，我的 debian11.9 系统中就没有看到这三个文件，只有~/.bashrc） 以上文件中，其实只有/etc/profile 和~/.bashrc 这两个是常用的、重要的。其他的几乎不用管，没有必要去深入了解。 如果你设置的变量只针对你或其他一个用户，那就修改~/.bashrc，如果是针对所有用户，就修改/etc/profile。 ","date":"2024-10-16","objectID":"/6e0e33a32ed0/:1:0","tags":["默认标签"],"title":"关于Linux环境变量配置文件","uri":"/6e0e33a32ed0/"},{"categories":["Linux"],"content":"交互式 shell 和非交互式 shell 交互式 shell：顾名思义，这种 shell 中的命令时由用户从键盘交互式地输入的，运行的结果也能够输出到终端显示给用户看。例如我们平常在终端输入的 cd 命令、vi 命令、mv 等都属于交互式的。 非交互式 shell：这种 shell 可能由某些自动化过程启动，不能直接从请求用户的输入，也不能直接输出结果给终端用户看。通常我们写的 shell 脚本都是非交互式的，通过 sh 直接运行该脚本文件。 ","date":"2024-10-16","objectID":"/6e0e33a32ed0/:2:0","tags":["默认标签"],"title":"关于Linux环境变量配置文件","uri":"/6e0e33a32ed0/"},{"categories":["Linux"],"content":"login shell 和 non-login shell login shell：取得 bash 时需要完整的登陆流程的，就称为 login shell。举例来说，我们登陆 tty1 ~ tty6 时，需要输入用户的账号与密码，此时取得的 bash 就称为 login shell non-login shell：取得 bash 接口的方法不需要重复登陆的举动，比如我们登陆 Linux 后，启动终端 Terminal，此时那个终端接口并没有需要再次的输入账号与密码，那个 bash 的环境就称为 non-login shell 了。又或者你在原本的 bash 环境下再次使用 bash 这个命令，建立了一个 bash 子进程，同样的也没有输入账号密码，那第二个 bash (子程序) 也是 non-login shell 。 注意：non-login shell 不会读取/etc/profile 和~/.bash_profile，而是读取~/.bashrc 来应用新的环境变量。 判断当前 shell 是 login 还是 non-login shell，可以简单的执行如下命令：echo $0 login shell 输出的结果类似 -bash 或 -su non-login shell 输出的结果类似 bash 或 su ","date":"2024-10-16","objectID":"/6e0e33a32ed0/:3:0","tags":["默认标签"],"title":"关于Linux环境变量配置文件","uri":"/6e0e33a32ed0/"},{"categories":["Linux"],"content":"关于 su 命令 su 命令一般是用于切换用户。但是 su root 和 su - root 是有区别的。 例如：su xjj 和 su -xjj 这两个都是切换到 xjj 用户。但是前者是以 non-login shell 的形式登陆，后者是以 login shell 的形式登录。 执行 su - xjj 执行 su xjj 因为 non-login shell 不会读取/etc/profile 和~/.bash_profile，而是读取~/.bashrc 来应用新的环境变量，所以会缺少一些变量。 我们应该使用 su -、su - root 或者 su -l root 以 login shell 方式切换至 root 用户，而不是 su 或者 su root 以 non-login shell 方式切换至 root 用户 ","date":"2024-10-16","objectID":"/6e0e33a32ed0/:4:0","tags":["默认标签"],"title":"关于Linux环境变量配置文件","uri":"/6e0e33a32ed0/"},{"categories":["默认分类"],"content":"方法 1：rc.local 文件位置在 /etc/rc.local。比较简单的方法，但是有些 linux 版本不支持，例如 debian 默认没有 rc.local 这个文件，但是有这个服务，并且这个服务是关闭的。 注意：/etc/rc.local 和/etc/rc.d/rc.local 区别在于，/etc/rc.local 是/etc/rc.d/rc.local 的软连接 ","date":"2024-09-20","objectID":"/7cbcb56c25d8/:1:0","tags":["默认标签"],"title":"Linux开机启动执行脚本","uri":"/7cbcb56c25d8/"},{"categories":["默认分类"],"content":"1）使用方式 # 先赋予文件执行权限，有就不用了 chmod +x /etc/rc.d/rc.local # 查看是否有执行权限 ls -l /etc/rc.d/rc.local # 将想要执行的命令添加到 rc.local 文件末尾即可，也可以执行 .sh 文件 ","date":"2024-09-20","objectID":"/7cbcb56c25d8/:1:1","tags":["默认标签"],"title":"Linux开机启动执行脚本","uri":"/7cbcb56c25d8/"},{"categories":["默认分类"],"content":"2）简单测试一下 先创建一个文件：touch /root/111.txt，在 rc.local 文件后面添加命令 /bin/echo \"abc11\" \u003e /root/111.txt，重启验证，查看命令是否执行。 重启后 ","date":"2024-09-20","objectID":"/7cbcb56c25d8/:1:2","tags":["默认标签"],"title":"Linux开机启动执行脚本","uri":"/7cbcb56c25d8/"},{"categories":["默认分类"],"content":"3）debian 系统没有 rc.local 怎么办 debian 虽然默认没有 rc.local 这个文件，但是有这个服务，并且这个服务是关闭的。 手动创建 /etc/rc.local 文件，写入以下内容 #!/bin/bash # # rc.local # # This script is executed at the end of each multiuser runlevel. # Make sure that the script will \"exit 0\" on success or any other # value on error. # # In order to enable or disable this script just change the execution # bits. # # By default this script does nothing. exit 0 然后赋予权限 chmod +x /etc/rc.local 启动 rc-local 服务，并设置为开机自启动。有警告不用管 systemctl enable --now rc-local # 设置为开机启动，并且，现在启动这个服务。--now：现在就启动这个服务 然后你就可以把需要开机启动的命令添加到 /etc/rc.local 文件，丢在 exit 0 前面即可，并尝试重启以后试试是否生效了。 ","date":"2024-09-20","objectID":"/7cbcb56c25d8/:1:3","tags":["默认标签"],"title":"Linux开机启动执行脚本","uri":"/7cbcb56c25d8/"},{"categories":["默认分类"],"content":"方法 2：systemd 参考： https://blog.csdn.net/lu_embedded/article/details/132424115 Linux 的 service 脚本一般存放在 /etc/systemd/ 和 /usr/lib/systemd 路径下，前者包含着多个 . target. wants 文件，如 multi-user. target. wants 等；而后者为安装软件生成 service 的目录，一般编写自己的 service 可以放在此目录下。但需要注意的是，位于 /usr/lib/systemd/ 中服务脚本可能会在下次更新时被覆盖。 无论是 /etc/systemd/ 还是 /usr/lib/systemd 目录，其中又包含 system 和 user 目录。前者是系统服务，开机不需要用户登录即可运行的服务；后者是用户服务，需要用户登录后才能运行的服务 在/etc/systemd/system/目录下创建一个 test.service [Unit] # 服务名称，可自定义 Description = cobaltstrike server [Service] Type = forking # 启动的命令 ExecStart = /bin/bash -c \"/usr/local/start.sh\" [Install] WantedBy = multi-user.target 完成服务脚本编写后，需要执行以下命令重新加载所有的 systemd 服务，否则会找不到 service 服务。 sudo systemctl daemon-reload 问题：超时报错，服务停止运行。有时脚本文件中特意设置很长的等待时间或要完成任务的时间本身就很长，如果在后台服务脚本中直接执行该脚本，就会收到超时信息，服务自动终止，这是我所不希望看到的 报错信息：xxxx.service: start operation timed out. Terminating. 解决这个问题也很简单，借助“bash -c”，bash -c 的作用是将一个长字符串当做一条完整的命令来执行，如果在脚本路径后面加上后台运行符号（\u0026），run.sh 脚本就会在后台运行，不会一直处于挂起状态，systemd 也就不会一直等待 run.sh 执行完成了。经过测试，完全符合预期，因此，最终的解决方案是： ExecStart=/bin/bash -c \"/data/leanote/bin/run.sh \u0026\" ","date":"2024-09-20","objectID":"/7cbcb56c25d8/:2:0","tags":["默认标签"],"title":"Linux开机启动执行脚本","uri":"/7cbcb56c25d8/"},{"categories":["默认分类"],"content":"方法 3：init.d 参考： https://blog.csdn.net/weixin_43425561/article/details/131447216 ","date":"2024-09-20","objectID":"/7cbcb56c25d8/:3:0","tags":["默认标签"],"title":"Linux开机启动执行脚本","uri":"/7cbcb56c25d8/"},{"categories":["默认分类"],"content":"方法 4：cron 通过定时任务执行命令或脚本。 crontab -e # 通过@reboot 命令，后面填入需要开机自启的命令或脚本路径。 # 注意脚本要有执行权限 重启后，查看 111.txt 文件 ","date":"2024-09-20","objectID":"/7cbcb56c25d8/:4:0","tags":["默认标签"],"title":"Linux开机启动执行脚本","uri":"/7cbcb56c25d8/"},{"categories":["默认分类"],"content":"老版本 linux 系统的安装源都不维护消失了，没有源安装一些常用软件比较麻烦，可以使用 iso 镜像文件搭建简易安装源，安装常用软件包 参考文章：yum源的三种搭建方式，CentOS 使用iso镜像安装本地 yum 源 ，使用iso镜像设置Ubuntu系统本地apt源，Debian如何配置局域网APT软件仓库 ","date":"2024-09-18","objectID":"/d27d0995f4f9/:0:0","tags":["默认标签"],"title":"自建yum源和apt源","uri":"/d27d0995f4f9/"},{"categories":["默认分类"],"content":"yum 源：网络搭建 这里以 Centos7 为例 1）服务器上需要安装有 apache 或 nginx 等服务器，并可以正常访问，这里使用 nginx 为例，服务器 ip 为 192.168.0.211 网站目录为 /var/www/html/ 2）上传 CentOS-7-x86_64-DVD-2009.iso 镜像到服务器上，然后在网站目录下新建一个文件夹，文件夹名随意。 mkdir /var/www/html/repo 3）将 iso 镜像挂载到创建的目录下 /var/www/html/repo mount CentOS-7-x86_64-DVD-2009.iso /var/www/html/repo 挂载完成后，repo 目录下会多出一些文件 4）启动一台 Centos7 服务器，来到 /etc/yum.repos.d 目录下，删除这个目录下的所有文件，创建一个文件 http.repo，写入以下内容。 #yum仓库名，可自定义 [http] #yum仓库的描述信息 name=repo_for_http #yum源的网络访问地址。url链接不要填错 baseurl=http://192.168.0.211/repo/ #启用仓库 enabled=1 # 不进行红帽标签检查 gpgcheck=0 至于删除的那些文件的作用和内容，有兴趣可以自行百度或查看上述参考文章。 验证 yum 源是否成功：yum repolist ","date":"2024-09-18","objectID":"/d27d0995f4f9/:1:0","tags":["默认标签"],"title":"自建yum源和apt源","uri":"/d27d0995f4f9/"},{"categories":["默认分类"],"content":"apt 源：网络搭建 这里以搭建 debian9 为例。 服务器上需要安装有 apache 或 nginx 等服务器，并可以正常访问，这里使用 nginx 为例，服务器 ip 为 192.168.0.211 网站目录为 /var/www/html/ 1）创建目录 debian9 mkdir /var/www/html/debian9 2）上传 iso 镜像文件，并挂载至 debian9 目录 mount -o loop debian-9.13.0-amd64-DVD-1.iso /var/www/html/debian9 3）查看 /var/www/html/debian9 目录，可以看到相关文件 4）启动一台 debian9 主机，编辑 /etc/apt/sources.list 文件，注释掉其他源，写入网络源 #注释掉其他源 deb [trusted=yes] http://192.168.0.211/debian9/ stretch main contrib # [trusted=yes]代表直接信任 # http://192.168.0.211/debian9/ ：软件仓库URL # stretch：版本代号 # main contrib：光盘上软件的组织结构 成功，这样就可以安装软件了，仅限 iso 镜像中自带的软件包 5）例如没有 vim，就可以从自己搭建的网络 apt 源进行安装，当然，仅限 iso 镜像中自带的软件包 ","date":"2024-09-18","objectID":"/d27d0995f4f9/:2:0","tags":["默认标签"],"title":"自建yum源和apt源","uri":"/d27d0995f4f9/"},{"categories":["默认分类"],"content":"服务器重启后挂载失效 因为上面只是临时挂载，重启后就失效了，可以再用 mount 命令挂载以便。如果你熟悉 Linux，可以将其写入配置文件，和挂载硬盘一样。 图省事的话可以将挂载命令在开机时自动执行，有两种方式实现： rc.local：先看看有没有这个配置文件，文件在 /etc/rc.local，debian 默认没有。将 mount -o loop debian-9.13.0-amd64-DVD-1.iso /var/www/html/debian9 写入 crontab：crontab -e 将 @reboot mount -o loop debian-9.13.0-amd64-DVD-1.iso /var/www/html/debian9 命令写入。 ","date":"2024-09-18","objectID":"/d27d0995f4f9/:3:0","tags":["默认标签"],"title":"自建yum源和apt源","uri":"/d27d0995f4f9/"},{"categories":["默认分类"],"content":"apt 源的配置文件说明 参考： https://www.cnblogs.com/beanmoon/p/3387652.html source.list 文件中每一行配置可以分为四个部分：deb http://mirrors.163.com/debian/ stretch main contrib deb 或者 deb-src：前者代表软件的位置，后者代表软件的源代码的位置 http：//mirrors.163.com/debian/ ：ftp 镜像的 url stretch：debian 系统的版本号。stretch-updates 是软件包状态，代表更新 main contrib：限定词 其中，前三个部分好理解，都是固定的样式，主要是第四部分的限定词，要理解清楚含义。 常见的三个限定词有：main、contrib、non-free main ：Debian 里最基本及主要且符合自由软件规范的软件 ( packages )。 contrib ：这里头软件虽然可以在 Debian 里头运作，即使本身属于自由软件但多半却是相依于非自由 ( non-free ) 软件。 non-free ：不属于自由软件范畴的软件。 一般软件的镜像源都包含这三个，比如腾讯的 debian10 镜像源配置为：deb https://mirrors.cloud.tencent.com/debian/ buster main contrib non-free 通过浏览器找到地址，打开对应为的地址 /dists/buster/ 可以看到 main、contrib、non-free 这三个文件夹 其次，我们在自己搭建的镜像源目录里也可以找到对应的目录，这里只有 main、contrib，没有 non-free 所以，在使用我们自己搭建的 debian9 镜像源时，配置为：deb [trusted=yes] http://192.168.0.211/debian9/ stretch main contrib 后面不要加 non-free。 不同的 Linux 系统源配置有些不同，比如 Ubuntu：deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse ","date":"2024-09-18","objectID":"/d27d0995f4f9/:4:0","tags":["默认标签"],"title":"自建yum源和apt源","uri":"/d27d0995f4f9/"},{"categories":["默认分类"],"content":"从hexo转到hugo hugo的环境安装比hexo要简单，hugo下个二进制文件就行，hexo还要下载nodeJS和一堆npm包，而且下载的时候因为网络问题还慢，所以就换了hugo。 之前用hexo时用的主题是butterfly，配置起来挺简单，文档全，也挺好看的。换了hugo之后，找了不少主题，最终选择用了FixIt FixIt主题很简洁，简单，够用，而且还有中文文档，上手挺快的。 Hugo常用命令 hugo version # 查看版本 hugo env # 版本和环境详细信息 # 创建项目 hugo new site hugo-demo # 会在当前文件夹下创建 hugo-demo 文件夹 ##### hugo-demo文件夹下的目录结构 ├─config.toml # 配置文件 ├─archetypes │ default.md ├─content # 存放博客和单页文章 ├─data # 存放其他数据 ├─layouts ├─public # 博客构建后的静态文件路径 ├─static # 用于存放静态资源 └─themes # 主题路径 ##### # 进入 hugo-demo 文件夹 hugo new posts/my-first-post.md # 文章在\\content\\posts里面 # 启动 hugo server -D # 显示草稿文章 ","date":"2024-06-24","objectID":"/8f5c6a2be833/:1:0","tags":["blog"],"title":"博客迁移","uri":"/8f5c6a2be833/"},{"categories":["默认分类"],"content":"Hugo使用GitHub Actions自动部署 创建两个仓库，一个用来放Hugo生成的静态文件（public），一个用来放Hugo的博客项目（private） 创建token，然后将token添加到private仓库的环境变量当中去 使用git管理本地的blog项目 在博客根目录中创建 .github/workflows/ 文件夹（可参考Github的Workflow有关内容），然后添加一个yaml文件，内容如下： name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest # 在什么环境执行 steps: # 步骤 - name: Checkout # 第一步 Checkout uses: actions/checkout@v4 with: fetch-depth: 0 # - name: Update Submodule # 第二步 更新子模块 # run: git submodule update --init --recursive - name: Setup Hugo # 第三步 Hugo 配置 uses: peaceiris/actions-hugo@v3 with: hugo-version: '0.144.2' # 使用的 Hugo 版本 extended: true # 是否使用 extended 版本 - name: Build Web # 第四步 构建 run: hugo -D # 构建命令 - name: Deploy Web # 第四步 发布 uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的KEY名称 }} EXTERNAL_REPOSITORY: 你的Github帐号/你的Github帐号.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 注意修改一下几点 hugo-version：修改你自己的版本，是否使用extended 如果定制主题后不想动态更新，也可以去掉第二步，本地也去掉Submodule。 PERSONAL_TOKEN指的是在hugo_demo_quickstart中配置的Sercet名称，不是Token本身，注意只要把“你的KEY名称”替换即可，“${{ secrets.xx }}”格式保持不变。 ","date":"2024-06-24","objectID":"/8f5c6a2be833/:2:0","tags":["blog"],"title":"博客迁移","uri":"/8f5c6a2be833/"},{"categories":["docker"],"content":"靶场镜像 # dvwa docker run -d -p 43301:3306 -p 48881:80 --restart=always --name=dvwa sagikazarmark/dvwa # pikachu docker run -d -p 43302:3306 -p 48882:80 --restart=always --name=pikachu area39/pikachu # sqli-labs docker run -d -p 43303:3306 -p 48883:80 --restart=always --name=sqli-labs acgpiano/sqli-labs # xss-labs docker run -d -p 43304:3306 -p 48884:80 --restart=always --name=xss-labs vulfocus/xss-labs # ssrf-labs docker run -d -p 43305:3306 -p 48885:80 --restart=always --name=ssrf-labs anhkhoa14592/ssrf-labs # webgoat 安装 docker run -d -p 48887:8080 -p 49091:9090 -e TZ=Asia/Shanghai --restart=always --name=webgoat webgoat/webgoat # bluelotus_xss 安装 docker run -d -p 48888:80 --restart=always --name=bluelotus_xss tanyiqu/bluelotus_xss_receiver 对于某些课程，您需要在同一时区运行容器。为此，您可以设置 TZ 环境变量。 https://hub.docker.com/r/webgoat/webgoat 使用 dvwa arm64 版本 镜像来源：petechua/docker-vulnerable-dvwa: 1.0 docker run -d -p 48881:80 --restart=always --name=dvwa-arm64 registry.cn-hangzhou.aliyuncs.com/lanhuli/bachang:dvwa-arm64 数据库登录：root 密码为空 用户：app 密码：vulnerables 注意：无法远程登录 x86 版本 镜像来源：sagikazarmark/dvwa:latest docker run -d -p 43301:3306 -p 48881:80 --restart=always --name=dvwa registry.cn-hangzhou.aliyuncs.com/lanhuli/bachang:dvwa MySQL 凭据配置为 DVWA 默认值： 用户：root 密码： p@ssw0rd 数据库： dvwa ","date":"2024-04-17","objectID":"/d72b8614ae35/:1:0","tags":["docker"],"title":"docker镜像仓库","uri":"/d72b8614ae35/"},{"categories":["docker"],"content":"webdav 服务镜像 源镜像仓库： https://hub.docker.com/r/bytemark/webdav docker run -d --name=webdav --restart always -v /srv/share/mybooks:/var/lib/dav \\ -e AUTH_TYPE=Basic -e USERNAME=admin -e PASSWORD=admin123 \\ -p 18888:80 \\ registry.cn-hangzhou.aliyuncs.com/lanhuli/webdav:latest 注意：阅读小说 app 使用时，AUTH_TYPE=Basic 必须使用 Basic，使用 Digest 会导致 401 报错。 ","date":"2024-04-17","objectID":"/d72b8614ae35/:2:0","tags":["docker"],"title":"docker镜像仓库","uri":"/d72b8614ae35/"},{"categories":["docker"],"content":"oracle 数据库镜像 ","date":"2024-04-17","objectID":"/d72b8614ae35/:3:0","tags":["docker"],"title":"docker镜像仓库","uri":"/d72b8614ae35/"},{"categories":["docker"],"content":"oracle-11g 源镜像仓库： https://hub.docker.com/r/oracleinanutshell/oracle-xe-11g 安装（Ubuntu 18.04） docker pull registry.cn-hangzhou.aliyuncs.com/lanhuli/oracle:11g docker run -d -p 115 21:1521 -p 100 22:22 -p 180 80:8080 -e ORACLE_ALLOW_REMOTE=true --name=oracle11g registry.cn-hangzhou.aliyuncs.com/lanhuli/oracle:11g 如果要，请运行此命令： -e ORACLE_ALLOW_REMOTE=true # 远程连接数据库 -e ORACLE_DISABLE_ASYNCH_IO=true # 禁用磁盘异步 IO -e ORACLE_ENABLE_XDB=true # 使用默认密码启用 XDB 用户 对于 APEX 用户： docker run -d -p 491 61:1521 -p 80 80:8080 oracleinanutshell/oracle-xe-11g # Login http://localhost:8080/apex/apex_admin with following credential: username: ADMIN password: admin 修改后的密码：Xjj #123 默认情况下，密码验证为禁用（密码永不过期） 。使用以下设置连接数据库： hostname: localhost port: 49161 sid: xe username: system 或者 sys password: oracle","date":"2024-04-17","objectID":"/d72b8614ae35/:3:1","tags":["docker"],"title":"docker镜像仓库","uri":"/d72b8614ae35/"},{"categories":["docker"],"content":"orcale-12c 源镜像仓库地址： https://hub.docker.com/r/zhuyijun/oracle-12c 下载镜像 docker pull registry.cn-hangzhou.aliyuncs.com/lanhuli/oracle:12c # 创建并运行容器，简单使用 docker run -d --name oracle12c -p 11521:1521 -p 15500:5500 --restart=always \\ -e ORACLE_SID=orcl \\ -e ORACLE_PDB=orclpdb1 \\ -e ORACLE_PWD=Oracle #123 \\ -e ORACLE_CHARACTERSET=al32utf8 \\ registry.cn-hangzhou.aliyuncs.com/lanhuli/oracle:12c 如要使用更多环境变量，参数如下 docker run --name oracle12c -p 11521:1521 -p 15500:5500 \\ -e ORACLE_SID=orcl \\ -e ORACLE_PDB=orclpdb1 \\ -e ORACLE_PWD=Oracle #123 \\ -e ORACLE_CHARACTERSET=al32utf8 \\ -e ORACLE_BASE=/opt/oracle \\ -e ORACLE_HOME=/opt/oracle/product/12.2.0.1/dbhome_1 \\ -e PATH=/opt/oracle/product/12.2.0.1/dbhome_1/bin:/opt/oracle/product/12.2.0.1/dbhome_1/OPatch/:/usr/sbin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin \\ -v /home/nicemoe/oradata:/opt/oracle/oradata \\ registry.cn-hangzhou.aliyuncs.com/lanhuli/oracle:12c 注意使用之前修改/home/nicemoe/oradata 为自己的 /d/docker/data/oradata 意思是 D:/docker/data/oradata 文件夹 其它使用： # 修改密码 docker exec \u003ccontainer name\u003e ./setPassword.sh \u003cyour password\u003e docker exec d38c6077ec85 ./setPassword.sh Oracle*123456 # 例如这样修改密码 # 访问 OEM Express # https://localhost:5500/em/ # 注意要用 https # 用户名、密码、容器名：system/sys、123456、orclpdb1 # 以 sysdba 身份登录：sys、123456、orclpdb1 ","date":"2024-04-17","objectID":"/d72b8614ae35/:3:2","tags":["docker"],"title":"docker镜像仓库","uri":"/d72b8614ae35/"},{"categories":["docker"],"content":"orcale-19c 源镜像仓库地址： https://hub.docker.com/r/zhuyijun/oracle-12c docker pull registry.cn-hangzhou.aliyuncs.com/lanhuli/oracle:19c # 创建并运行容器，简单使用 docker run -d --name oracle19c -p 21521:1521 -p 25500:5500 --restart=always \\ -e ORACLE_SID=orcl \\ -e ORACLE_PDB=orclpdb1 \\ -e ORACLE_PWD=Oracle#123 \\ -e ORACLE_CHARACTERSET=al32utf8 \\ registry.cn-hangzhou.aliyuncs.com/lanhuli/oracle:19c 如要使用更多环境变量，参数如下 docker run --name myoracle -p 1521:1521 -p 5500:5500 \\ -e ORACLE_SID=orcl \\ -e ORACLE_PDB=orclpdb1 \\ -e ORACLE_PWD=123456 \\ -e ORACLE_CHARACTERSET=zhs16gbk \\ -e ORACLE_BASE=/opt/oracle \\ -e ORACLE_HOME=/opt/oracle/product/12.2.0.1/dbhome_1 \\ -e PATH=/opt/oracle/product/12.2.0.1/dbhome_1/bin:/opt/oracle/product/12.2.0.1/dbhome_1/OPatch/:/usr/sbin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin \\ -v /home/nicemoe/oradata:/opt/oracle/oradata \\ registry.cn-hangzhou.aliyuncs.com/lanhuli/oracle:19c 其它使用： # 修改密码 docker exec \u003ccontainer name\u003e ./setPassword.sh \u003cyour password\u003e docker exec d38c6077ec85 ./setPassword.sh Oracle*123456 # 例如这样修改密码 # 访问 OEM Express # https://localhost:5500/em/ # 注意要用 https # 用户名、密码、容器名：system/sys、123456、orclpdb1 # 以 sysdba 身份登录：sys、123456、orclpdb1 ","date":"2024-04-17","objectID":"/d72b8614ae35/:3:3","tags":["docker"],"title":"docker镜像仓库","uri":"/d72b8614ae35/"},{"categories":["docker"],"content":"oracle-19c-arm64 源镜像仓库： https://hub.docker.com/r/beatrizzallo/oracle-19e-m1 使用提供的映像生成容器的命令： docker run -d -p 180 80:8080 -p 115 21:1521 --name \"oracle19\" -e ORACLE_SID=\"oracle_sid\" registry.cn-hangzhou.aliyuncs.com/lanhuli/oracle: 19c-arm64 创建并初始化（检查已完成配置的日志）后，您可以为用户生成一个新通道，如下所示： docker exec \"image-name\" /opt/oracle/setPassword.sh \"new-pass\" # 对密码有复杂度有要求 Oracle #123 ","date":"2024-04-17","objectID":"/d72b8614ae35/:3:4","tags":["docker"],"title":"docker镜像仓库","uri":"/d72b8614ae35/"},{"categories":["linux"],"content":"linux编译安装指令 configure、make、make install 命令 configure：配置，是用来检测你的安装平台的目标特征的。比如它会检测你是不是有 CC 或 GCC，并不是需要 CC 或 GCC，它是个 shell 脚本。configure 脚本负责在使用的系统上准备好软件的构建环境。确保接下来的构建和安装过程所需要的依赖准备好，并且搞清楚使用这些依赖需要的东西。 make：构建，用来编译，它从 Makefile 中读取指令，然后编译。下载的源码包一般没有一个最终的 Makefile 文件，一般是一个模版文件，然后 configure 根据系统的参数生成一个定制化的 Makefile 文件。这个过程会执行在 Makefile 文件中定义的一系列任务将软件源代码编译成可执行文件。 make install：安装，它也从 Makefile 中读取指令，安装到指定的位置。make install 命令就是将可执行文件、第三方依赖包和文档复制到正确的路径。 清除 make 生成的文件：make clean 清除 make 和 configure 生成的文件，包括 Makefile：make distclean ","date":"2024-03-01","objectID":"/8e7beb29bf97/:0:0","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"apt 源安装 php 由于 debian 11 带的 php 版本是 7.4，有点老，所以我们可以使用 debian 开发者 Ondřej Surý 维护的 php 源 deb.sury.org 。 注意：以下方式还可以安装 php 5.6 版本 # 首先，使用下面的命令安装所须的软件包： apt install ca-certificates apt-transport-https software-properties-common -y # 安装所须软件包后，使用以下命令将 Sury 存储库添加到 APT： echo \"deb [https://packages.sury.org/php/](https://packages.sury.org/php/) $(lsb_release -sc) main\" | tee /etc/apt/sources.list.d/sury-php.list # 然后，使用以下命令下载并添加 GPG 密钥： wget -qO - [https://packages.sury.org/php/apt.gpg](https://packages.sury.org/php/apt.gpg) | apt-key add - # 上述添加 GPG 密钥的命令会提示 Warning: apt-key is deprecated，但是可以执行成功，如果不想要报 Warning 可以换成下面的命令： wget -O /etc/apt/trusted.gpg.d/php.gpg [https://packages.sury.org/php/apt.gpg](https://packages.sury.org/php/apt.gpg) # 完成后，使用以下命令更新存储库，到此，sury 源添加完成。 apt update 安装 php 指定版本 # 如果要安装 php 的最新版本，可以执行： apt install php-fpm php-mysql php-mbstring php-curl php-dom php-imagick php-zip php-gd php-intl # 如果要安装指定的版本，例如安装 php8.0，可以执行： apt install php8.0-fpm php8.0-mysql php8.0-mbstring php8.0-curl php8.0-dom php8.0-imagick php8.0-zip php8.0-gd php8.0-intl apt install php5.6-fpm php5.6-mysql php5.6-mbstring php5.6-curl php5.6-dom php5.6-imagick php5.6-zip php5.6-gd php5.6-intl # 注意，使用命令 apt install php8.0 后，会一并安装Apache。 # php 指的应该是整套能运行 php 的环境，php 需要在 libapache2-mod-php5, libapache2-mod-php5filter, php5-cgi, or php5-fpm 以上环境之一运行，如果没有则默认选了第一种，所以会推荐安装 apache。参考回答： https://learnku.com/articles/55616](https://learnku.com/articles/55616 启动 php-fpm：systemctl status php8.0-fpm.service ","date":"2024-03-01","objectID":"/8e7beb29bf97/:1:0","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"源码编译安装 php 安装编译程序和相关依赖，可以运行 ./configure 命令检查。缺啥安装啥 apt-get install gcc make libxml2 libxml2-dev zlib1g-dev libcurl4-gnutls-dev libreadline-dev 创建安装目录 mkdir -p /usr/local/php/5.6 下载 php 5.6 的源码包，解压后进入源码文件夹下 生成配置文件 ./configure --prefix=/usr/local/php/5.6 --with-config-file-path=/usr/local/php/5.6 --enable-fpm --enable-cli 出现问题：报错 Cannot find OpenSSL's libraries 运行命令：find / -name libssl.so，输出：/usr/lib/x86_64-linux-gnu/libssl.so 建立软连接：ln -s /usr/lib/x86_64-linux-gnu/libssl.so /usr/lib 重新编译即可 编译、安装 make \u0026\u0026 make install 复制 php.ini # php.ini-development（开发环境用）与php.ini-production（生产环境用） cp php.ini-production /usr/local/php/5.6/php.ini 复制启动脚本 cp ./sapi/fpm/init.d.php-fpm /etc/init.d/php5.6-fpm chmod +x /etc/init.d/php5.6-fpm 复制生成 php-fpm.conf 文件 cp /usr/local/php/5.6/etc/php-fpm.conf.default /usr/local/php/5.6/etc/php-fpm.conf 修改 php-fpm.conf 去掉 pid = run/php-fpm.pid 前面的分号 并在listen = 127.0.0.1:9000后面添加 listen.allowed_clients = 127.0.0.1 参考： https://blog.csdn.net/qq_43017750/article/details/105053831 ","date":"2024-03-01","objectID":"/8e7beb29bf97/:2:0","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"安装 nginx 安装：apt install nginx nginx 配置文件 root、alias 配置区分： https://zhuanlan.zhihu.com/p/131009164 ","date":"2024-03-01","objectID":"/8e7beb29bf97/:3:0","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"php 相关配置 server { ..... # pass PHP scripts to FastCGI server #location ~ \\.php$ { # include snippets/fastcgi-php.conf; # # # With php-fpm (or other unix sockets): # fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; # # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; #} location ~ \\.php$ { fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; fastcgi_pass unix:/run/php/php5.6-fpm.sock; # 使用unix sockets # fastcgi_pass 127.0.0.1:9000; # tcp sockets } } ","date":"2024-03-01","objectID":"/8e7beb29bf97/:3:1","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"反向代理配置 server { listen 80; # 代理服务器监听的端口 server_name 192.168.10.1;# 代理服务器地址或绑定域名 # 访问http://192.168.10.1/，到http://192.168.10.2上 location / { # 访问80端口后的所有路径都转发到 proxy_pass 配置的ip中 proxy_pass http://192.168.10.2; # 配置真实网站的ip地址和端口号 【注：url地址需加上http:// 或 https://】 } # 访问http://192.168.10.1/dvwa/这个路径，实际代理到http://127.0.0.1:49154/ location /dvwa/ { proxy_pass http://127.0.0.1:49154/; # 加不加 / 的区别。绝对路径和相对路径的区别 # 加反斜杠：访问http://192.168.10.1/dvwa/代理到http://127.0.0.1:49154/下 # 不加反斜杠：访问http://192.168.10.1/dvwa/代理到http://127.0.0.1:49154/dvwa/下 proxy_redirect / /dvwa/; # 处理302跳转事件，将location的 / 路径，替换为/dvwa/，保证路径的正确。 } # 访问http://192.168.10.1/pikachu/这个路径，实际代理到http://127.0.0.1:49156/ location /pikachu/ { proxy_pass http://127.0.0.1:49156/; } # 访问http://192.168.10.1/sqli-lab/这个路径，实际代理到http://127.0.0.1:49158/ location /sqli-lab/ { proxy_pass http://127.0.0.1:49158/; } } ","date":"2024-03-01","objectID":"/8e7beb29bf97/:3:2","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"ssl 配置 server { #监听443端口 listen 443; #你的域名 server_name lanhuli.top; ssl on; #ssl证书的pem文件路径 ssl_certificate /root/cert/www.lanhuli.top.pem; #ssl证书的key文件路径 ssl_certificate_key /root/cert/www.lanhuli.top.key; location / { root /var/www/html; index index.php index.html; } location ~ \\.php$ { include fastcgi_params; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; fastcgi_pass unix:/run/php/php8.0-fpm.sock; } } server { listen 80; server_name lanhuli.top; #将请求转成https rewrite ^(.*)$ [https://$host$1](https://$host$1) permanent; } ","date":"2024-03-01","objectID":"/8e7beb29bf97/:3:3","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"basic 认证配置 1）使用本机认证：auth_basic。还有另一种方式，这个比较简单，就用这个就行。 需要先安装 htpasswd 工具：yum install httpd-tools 或者 apt install apache2-utils 生成密码文件：htpasswd -c ./mypasswd 用户名，然后输入密码。这个存放的文件路径可以随意指定（这个文件的存放路径必须要让 Nginx 有权限访问到。可以放到 /usr/local/share/mypasswd）。 2）修改 Nginx 的配置文件 注意：不要修改 Nginx 自带的默认配置文件，一定要新建一个配置文件。 新建配置文件：touch /etc/nginx/conf.d/my-nginx.conf 写入内容 server { listen 26660; # 监听端口 server_name 127.0.0.1; index index.html; # auth_basic 认证配置，就这两行 auth_basic \"User Authentication\"; auth_basic_user_file /usr/local/share/mypasswd; # 注意，这个文件的存放路径必须要让 Nginx 有权限访问到，不然报错 # Nginx 代理转发 location / { proxy_pass http://127.0.0.1:80 ; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } 如果使用 curl 和 wget 命令进行下载： curl -u username:password URL wget --http-user=username --http-passwd=passwd URL 上传文件限制大小问题 1）nginx 配置问题 nginx 服务器报错：413 Request Entity Too Large 打开配置文件 /etc/nginx/nginx.conf。在 http{}段中加入 client_max_body_size 100m; 100 m 为允许最大上传的大小。然后重启 nginx 2）php 配置问题 上传的文件大小超过 php.ini 文件中定义的 upload_max_filesize 值 打开 php.ini，把 upload_max_filesize 和 post_max_size 修改为 100 M，然后重启。 注意： 通过 find 命令查找发现有两个 php.ini 文件 查看 phpinfo，发现使用的是 fpm 下的文件 ","date":"2024-03-01","objectID":"/8e7beb29bf97/:3:4","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"安装 mysql ","date":"2024-03-01","objectID":"/8e7beb29bf97/:4:0","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"安装 1）配置 MySQL 存储库 MySQL 全球最流行的开源关系型数据库管理系统，它在默认的 Debian 存储库中不可用。 MariaDB 是 Debian 10 中的默认数据库系统。MySQL 已经为我们提供了一个 Debian 的 Deb 包，通常是十几 K。我们选择 download。使用 wget 进行下载 wget https://dev.mysql.com/get/mysql-apt-config_0.8.29-1_all.deb sudo dpkg -i mysql-apt-config_0.8.29-1_all.deb 2）安装 MySQL sudo apt update sudo apt install mysql-server 安装完成后，MySQL 服务会默认自动运行。 ","date":"2024-03-01","objectID":"/8e7beb29bf97/:4:1","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"重置密码（注意版本） 1、知道旧密码，登陆 MySQL MySQL 8.0 之前：set password for root@localhost = password ('root 123'); MySQL 8.0 之后：ALTER user root@localhost IDENTIFIED BY 'root 0123'; 问题： 简单密码不符合策略 这个与验证密码策略 validate_password_policy 的值有关。默认是 1，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。如果不想设置 8 位，或者想设置简单点，可以选择 Policy 0. 在修改策略之前它需要你先改密码 这是其它的一些密码设置 SHOW VARIABLES LIKE 'validate_password%'; set global validate_password_policy=0; set global validate_password_length=6; set password for root@localhost = password ('root 123'); 2、忘记密码 第一步：在命令行输入 net stop mysql 命令关闭 mysql 服务 第二步：使用–skip-grant-tables 选项启动 mysql 服务（服务器将不加载权限判断，任何用户都能访问数据库） 在命令行输入 mysqld –skip-grant-tables 命令运行之后，用户无法再输入指令，此时如果在任务管理器中可以看到名称为 mysqld 的进程，则表示可以用 root 用户登录服务器了 第三步：打开另一个命令行窗口，输入不加密码的登录命令 mysql -u root 登录成功后可以使用 update 语句修改密码 修改完成后，必须使用 flush privileges 语句刷新权限表，这样新的密码才能生效 第四步：将输入 mysqld –skip-grant-tables 命令的命令行窗口关闭，接下来就可以使用新密码登录 mysql 服务器了 3、root 用户自带了一个随机密码 一般来说 mysql 安装完之后默认是没有密码的，但是在执行 mysqld –initialize 之后会初始化密码 (默认密码为随机的高强度密码)这个密码会储存在错误日志中。 找到日志：find / -name \"mysqld.log\" 打开查找：cat /var/log/mysqld.log|grep password ","date":"2024-03-01","objectID":"/8e7beb29bf97/:4:2","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"安装 Samba 安装： apt install smaba smbclient samba-common # 安装 smaba 即可 # 用于实现 SMB/CIFS（Server Message Block/Common Internet File System）协议。samba 服务器提供了文件共享和打印服务，允许 Windows 客户端通过网络与 Linux/UNIX 服务器交互 # samba 软件包的公共文件和库。它包含一些共享的配置文件、脚本、语言文件和其他公共资源，这些资源被 samba 服务器和客户端程序所共享和使用。 # samba 软件包的客户端组件。它提供了一些用于与 samba 服务器进行交互的命令行工具，例如 smbclient、smbget 和 smbtree 等。这些工具允许用户在 Linux/UNIX 系统上访问和管理远程的 samba 共享文件夹。 指定账户访问 # 创建一个用来共享的目录 sudo mkdir -p /home/work/sharedir # 创建一个账户，用来登录 sudo useradd smbuser -s /usr/sbin/nologin # 修改文件权限使得 smbuser 用户能够访问共享路径 sudo chown smbuser: smbuser /home/work/sharedir # 将用户 smbuser 添加到 samba 的 smbpasswd file 中（即在 samba 服务中注册该账户） sudo smbpasswd -a smbuser 修改 samba 配置文件（/etc/samba/smb.conf） # 用户访问时看到的名字 [myshare] # 共享文件夹的注释说明 comment = 锐捷小主机共享 # 需要填写实际的共享文件夹的路径 path = /srv/samba/share # 设置为可写入 writable = yes #设置可访问的用户 ，此处为前面添加的用户 smbuser（注意 users 不要拼写错误） valid users = xujiajun #是否允许访客 ，否 guest ok = no #可浏览 ，是 browsable = yes # 新建文件的权限 create mask = 0777 # 新建目录即文件夹的权限 directory mask = 0777 配置含义 [共享名称]: 共享中看到的共享目录名 comment = 共享的描述. path = 共享目录路径 (可以用%u、%m 这样的宏来代替路径如:/home/share/%u) browseable = yes/no 指定该共享是否在“网上邻居”中可见。 writable = yes/no 指定该共享路径是否可写。 read only = yes/no 设置共享目录为只读 (注意设置不要与 writable 有冲突) available = yes/no 指定该共享资源是否可用。 admin users = bobyuan，jane 指定该共享的管理员, 用户验证方式为“security=share”时，此项无效。 valid users = bobyuan，jane 允许访问该共享的用户或组-“@+组名” invalid users = 禁止访问该共享的用户与组 (同上) write list = 允许写入该共享的用户 public = yes/no 共享是否允许 guest 账户访问。 guest ok = yes/no 意义同“public”。 create mask = 0700 指定用户通过 Samba 在该共享目录中创建文件的默认权限。0600 代表创建文件的权限为 rw------- directory mask = 0700 指定用户通过 Samba 在该共享目录中创建目录的默认权限。0600 代表创建目录的权限为 rwx------","date":"2024-03-01","objectID":"/8e7beb29bf97/:5:0","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"安装 frp frp 项目地址： https://github.com/fatedier/frp 官方文档： https://gofrp.org/zh-cn/ ssh 转发： https://gofrp.org/zh-cn/docs/examples/ssh/ 服务端配置，修改 frps.toml。新版 frp 配置和旧版的字段名不太一样。注意：新版字符串要加双引号。参考：新版参数 [common] # 服务端监听地址，用于接收 frpc 的连接，默认监听 0.0.0.0。 bindAddr = \"0.0.0.0\" # 10000 为服务端 frp 与客户端 frp 相互通信的端口。服务端监听端口，默认值为 7000。 bindPort = 10000 # HTTP 请求的监听端口为 8080 vhostHTTPPort = 8080 # 设置连接密钥 token=\"qwer1234\" # 设置 frp 后台端口 dashboard_port=8000 # 设置后台帐号和密码 dashboard_user=\"admin\" dashboard_pwd = \"××××××××××\" 客户端配置，修改 frpc.toml [common] # 服务器的公网地址 serverAddr = \"103.246.244.137\" # 10000 为服务端 frp 与客户端 frp 相互通信的端口 serverPort = 10000 # 设置连接密钥 token = \"qwer1234\" [[proxies]] name = \"web\" # name 值唯一 type = \"http\" localPort = 80 customDomains = [\"omv.lanhuli.top\"] [smb] # 文件共享 smb 协议通过 tcp 通信 type = tcp local_ip = 127.0.0.1 # smb 协议的本地端口 local_port = 445 # remotePort 表示在 frp 服务端监听的端口，访问此端口的流量将被转发到本地服务的相应端口。 # 设定远程端口，当访问服务器的 8090 端口时，数据会被转发到本地 445 端口 remote_port = 8089 服务端运行 frp 命令：./frps -c frps.toml 客户端运行 frp 命令：./frpc -c frpc.toml 我的配置 bindPort = 16669 auth.token = \"123456\" # 服务端面板 webServer.addr = \"0.0.0.0\" webServer.port = 16668 webServer.user = \"123456789\" webServer.password = \"123456789\" 客户端 serverAddr = \"x.x.x.x\" serverPort = 16669 auth.token = \"123456\" # 客户端面板 webServer.addr = \"0.0.0.0\" webServer.port = 7400 webServer.user = \"admin\" webServer.password = \"admin\" [[proxies]] name = \"omv\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 26660 remotePort = 16660 # docker 版的 qbittorrent 服务 [[proxies]] name = \"qbit\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 16661 remotePort = 16661 # docker 版的 jellyfin 服务 [[proxies]] name = \"jellyfin\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 26662 remotePort = 16662 2、后台运行 frp 程序 参考官网： https://gofrp.org/zh-cn/docs/setup/systemd/ 创建 frps.service 文件 sudo vim /etc/systemd/system/frps.service 写入内容 [Unit] # 服务名称，可自定义 Description = frp server After = network.target syslog.target Wants = network.target [Service] Type = simple # 启动 frps 的命令，需修改为您的 frps 的安装路径 ExecStart = /path/to/frps -c /path/to/frps.toml [Install] WantedBy = multi-user.target 使用 systemd 命令管理 frps 服务 # 启动 frp sudo systemctl start frps # 停止 frp sudo systemctl stop frps # 重启 frp sudo systemctl restart frps # 查看 frp 状态 sudo systemctl status frps 设置 frps 开机自启动 sudo systemctl enable frps 客户端方法同上 ","date":"2024-03-01","objectID":"/8e7beb29bf97/:6:0","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["linux"],"content":"安装 dnsmasq 安装：apt install dnsmasq ","date":"2024-03-01","objectID":"/8e7beb29bf97/:7:0","tags":["nginx","mysql","php"],"title":"debian系统安装服务软件","uri":"/8e7beb29bf97/"},{"categories":["默认分类"],"content":"项目地址： https://github.com/firesunCN/BlueLotus_XSSReceiver 自己做成了一个 docker 镜像，可以直接使用。 docker pull bluefoxqaq/bluelotus_xss_docker:2.0 # 这里映射宿主机的80端口，其它端口有问题，admin.php页面会不断刷新。80端口就没事 docker run -d -p 80:80 -it --name=bluelotus bluefoxqaq/bluelotus_xss_docker:2.0 # 访问ip:80即可 登录时需要完整的地址，例如：http://ip/login.php ，这个login.php不会自动添加。 镜像制作过程 下载所需要的文件，解压后是个名为 xcc 的文件夹，进入 xcc 文件夹，运行 docker build 命令 docker build -f ./Dockerfile -t bluelotus_docker:1.0 . # 注意后面的点号 所需文件下载地址：xcc.zip 其中 Dockerfile 文件内容如下： FROM debian:9.4 # 上传apt源配置 COPY ./sources.list /etc/apt/sources.list # 安装Nginx RUN apt update ; apt install nginx -y # 上传Nginx配置 COPY mynginx.conf /etc/nginx/sites-enabled/default # 上传php源码 COPY php-5.6.4 /root/php-5.6.4 WORKDIR /root/php-5.6.4 RUN apt install gcc make libxml2 libxml++2.6-dev -y # 安装编译工具 RUN mkdir /usr/local/php\u0026\u0026mkdir /usr/local/php/5.6 # 创建安装目录 RUN ./configure --prefix=/usr/local/php/5.6 --with-config-file-path=/usr/local/php/5.6 --enable-fpm --enable-cli # php安装脚本 RUN make \u0026\u0026 make install # 编译安装 RUN cp php.ini-production /usr/local/php/5.6/php.ini\u0026\u0026cp ./sapi/fpm/init.d.php-fpm /etc/init.d/php5.6-fpm\u0026\u0026chmod +x /etc/init.d/php5.6-fpm # 上传php-fpm.conf COPY php-fpm.conf /usr/local/php/5.6/etc/php-fpm.conf RUN groupadd nobody # 添加nobody组 # 上传网址源码 RUN rm -r /var/www/html COPY bluelotus /var/www/html RUN chmod -R 777 /var/www/html EXPOSE 80 #启动Nginx和php COPY start_nginx_php.sh /root/start_nginx_php.sh WORKDIR /root/ RUN chmod 777 /root/start_nginx_php.sh CMD [\"sh\",\"-c\",\"./start_nginx_php.sh\"] ","date":"2024-02-17","objectID":"/e4880266d50b/:0:0","tags":["默认标签"],"title":"xss盲打平台bluelotus搭建","uri":"/e4880266d50b/"},{"categories":["docker"],"content":"Dockerfile常用指令 Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 Dockerfile 的指令是从上到下依次执行。其实跟我们直接敲命令差不多。 # 一些常见指令 FROM：指定基础镜像，必须 WORKDIR ：设置指令的工作目录 COPY ：将文件或目录复制到镜像中，第一个参数是宿主机文件，第二个是容器 RUN ：镜像创建阶段中执行的命令 CMD ：容器创建阶段中执行的命令，可以被覆盖。例如在docker run 镜像id xxxx时 EXPOSE ：声明端口号 RUN 和 CMD 的区别：RUN 是在创建镜像时执行的命令，一般是安装、下载、创建文件之类的。CMD 是在创建容器时才会执行的命令，一般是启动程序的命令。 CMD 两种写法 exec 模式：不会通过 shell 执行相关的命令，所以向 $HOME 这样的环境变量是获取不到的。 格式：CMD [\"可执行文件\",\"参数1\",\"参数2\"] shell 模式：docker 以 /bin/sh -c command 的方式执行命令，也就是说容器的 1 号进程是 bash 进程。 格式：CMD command 例如： CMD [\"/bin/echo\",\"hello\"]，会输出 hello。 CMD echo hello，也会输出 hello，但是他其实是这样的 CMD [\"\",\"-c\",\"echo hello\"] CMD echo $HOME 实际执行是 CMD [ \"sh\", \"-c\", \"echo $HOME\" ] 推荐使用 exec 模式，如果命令太多可以写成一个脚本，然后运行这个脚本。 ","date":"2024-02-17","objectID":"/4b704cc713a3/:1:0","tags":["docker"],"title":"Dockerfile文件","uri":"/4b704cc713a3/"},{"categories":["docker"],"content":"Dockerfile例子 一个简单的 Dockerfile：安装 Nginx 并启动 # 需要一个Debian 9.4的镜像 FROM debian:9.4 # 上传apt源配置 COPY ./sources.list /etc/apt/sources.list # 安装Nginx RUN apt update ; apt install nginx -y # 声明端口，仅仅只是一个声明，描述需要哪些端口 EXPOSE 80 #启动Nginx和php COPY start_nginx_php.sh /root/start_nginx_php.sh WORKDIR /root/ RUN chmod 777 /root/start_nginx_php.sh CMD [\"sh\",\"-c\",\"./start_nginx_php.sh\"] FROM debian:9.4：指定一个基础镜像，需要一个 Debian 9.4 的镜像 COPY ./sources.list /etc/apt/sources.list：将宿主机的 ./sources.list 复制到容器的 /etc/apt/sources.list，这个 sources.list 文件，是提前准备好的apt 源。 RUN apt update ; apt install nginx -y：执行两条命令，更新源和安装 Nginx，这里用了分隔符执行两个命令，也可以分开写，用两个 RUN。 COPY start_nginx_php.sh /root/start_nginx_php.sh：将Nginx启动脚本复制到容器。脚本内容在后面说。 WORKDIR /root/：来到容器的 /root/ 目录下，也就是存放 Nginx 启动脚本的目录。 RUN chmod 777 /root/start_nginx_php.sh：赋予 Nginx 启动脚本执行权限。 CMD [\"sh\",\"-c\",\"./start_nginx_php.sh\"]：运行脚本。 先看看启动脚本内容 #!/bin/sh /usr/sbin/service nginx start /bin/bash ","date":"2024-02-17","objectID":"/4b704cc713a3/:2:0","tags":["docker"],"title":"Dockerfile文件","uri":"/4b704cc713a3/"},{"categories":["docker"],"content":"docker 的机制 1、Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。 2、docker 容器运行必须有一个前台进程，如果没有前台进程执行，容器认为空闲，就会自行退出。一般常见的启动参数是 docker run -dit centos /bin/bash，/bin/bash 就是一个前台进程，你也可以用 top 之类的命令。 3、使用 CMD service nginx start 命令作为容器启动命令的话，这个命令执行成功后就会退出，紧接着容器也会自动退出。对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 4、使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而 CMD service nginx start 会被理解为 CMD [ \"sh\", \"-c\", \"service nginx start\"]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。 5、所以在启动脚本当中最后是 /bin/bash 命令。防止容器退出。也可以将 nginx 放到前台运行 CMD [\"nginx\", \"-g\", \"daemon off;\"] 注意：docker run xxxxxxxxxxxxx /bin/bash ，这里的/bin/bash 会覆盖掉 CMD 的命令。 ","date":"2024-02-17","objectID":"/4b704cc713a3/:3:0","tags":["docker"],"title":"Dockerfile文件","uri":"/4b704cc713a3/"},{"categories":["漏洞复现"],"content":"漏洞复现（Vulhub靶场） 进入到Vulhub靶场的/vulhub/webmin/CVE-2019-15107目录下，运行docker-compose up -d命令启动靶场。 输入用户名和密码，使用burp进行抓包。 修改数据包的请求地址为/password_change.cgi，请求体payload改为user=rootxx\u0026pam=\u0026expired=2\u0026old=test|id\u0026new1=test2\u0026new2=test2，id 是要执行的命令。 发送请求，可以在响应体中找到命令执行成功的响应数据。 使用docker-compose down命令移除环境。 ","date":"2023-10-28","objectID":"/ddede4f30805/:1:0","tags":["webmin"],"title":"webmin远程代码执行(CVE-2019-15107)","uri":"/ddede4f30805/"},{"categories":["漏洞复现"],"content":"msf利用 使用https://vulfocus.cn/在线靶场，启动环境，访问漏洞地址：https://123.58.224.8:48832/，注意要加https进行访问 启动vps上的msf，进入命令行模式，搜索webmin相关的poc 这里使用第十个脚本，设置脚本参数 设置好参数后，查看一下 没问题后，输入run，可以成功 ","date":"2023-10-28","objectID":"/ddede4f30805/:2:0","tags":["webmin"],"title":"webmin远程代码执行(CVE-2019-15107)","uri":"/ddede4f30805/"},{"categories":["默认分类"],"content":"关闭 win 10 (专业版) 系统更新，只在专业版win10测试过可行。其它版本不清楚。 打开组策略，按图找到 Windows 更新。 有三个配置需要更改 1）配置自动更新：禁用掉 2）指定 Intranet Microsoft 更新服务位置：启用，修改网址。 3）不要连接任何 Windows 更新 Intranet 位置：启用 三个选项设置好后，更新就会因无法联网而终止。记得重启 ","date":"2023-10-06","objectID":"/0c18f16dae35/:0:0","tags":["默认标签"],"title":"win10关闭自动更新","uri":"/0c18f16dae35/"},{"categories":["默认分类"],"content":"设置虚拟机静态ip保持不变 宿主机更换网络后，ip 地址变动，同时虚拟机也会变动 ip 地址，如果是笔记本的话，频繁更换网络导致虚拟机地址也要频繁修改，很麻烦。 虚拟机在桥接模式下，通过 dhcp 获得一个和宿主机同网段的一个 ip，二者可以互通，可以正常访问互联网。但是如果宿主机换了一个网络，例如从 192.168.31.96 变成了 192.168.32.196，那么虚拟机的 ip 地址也要变为同 32 网段的 ip 地址才可以进行互通和上网。每次宿主机切换网络，虚拟机的地址也要跟着变动，这很麻烦，因为每次都有重新确认虚拟机新分配的 ip 地址。 我希望虚拟机的 ip 地址不变，同时还可以正常互通和上网。无论宿主机如何切换网络，虚拟机的地址永远都不会变动。 ","date":"2023-10-05","objectID":"/4013e4eb4949/:1:0","tags":["默认标签"],"title":"设置虚拟机静态ip保持不变","uri":"/4013e4eb4949/"},{"categories":["默认分类"],"content":"实际操作 有两台主机，宿主机和虚拟机处于同一网络，ip 地址如下（桥接模式） 宿主机 ip：192.168.31.96 虚拟机 ip：192.168.31.64 二者之间正常通信，且均可以访问互联网。如下图 现在，我们想要切换网络时保持虚拟机的ip地址不变动，进行以下设置 点击 VMware 的编辑-虚拟网络编辑器，点击更改设置。 点击添加网络 添加一个网络，这里我用的 VMnet17，点击确定。 取消勾选 DHCP 服务，同时将子网段设一个你想要的值，这里使用了 17 网段，点击确定即可。 打开笔记本宿主机的网络设置，可以看到新添加的 VMnet17 网卡 选择无线网卡，右键-属性-共享-选择 VMnet17，点击确定 点击确定后有一个弹窗，点击是，他会将 VMnet17 网卡改为 137 网段，我们需要将它改为 17 网段，就是自定义的网段。 将 VMnet17 网卡改为如下所示，将 137 改为 17，添加 dns。点击确定 将虚拟机的网络连接改为自定义，启动虚拟机。 配置虚拟机的 ip 地址：192.168.17.100，子网掩码，网关（VMnet 17 网卡的地址192.168.17.1）和 dns（同 192.168.17.1 就可以了）。保存即可 经过测试，发现虚拟机可以 ping 通宿主机，也可通外网。 虚拟机可以上外网，访问微博 宿主机可以通过 ssh 连接虚拟机 现在，我们将笔记本宿主机的网络进行切换，连接手机热点。同样也可互通和上网。但是这里我出现了个问题，就是换成手机热点之后，宿主机和虚拟机之间可以互通，但是虚拟机上不了网，我切换了好多次都不行。我把热点关了再重新连接，他又好了，虚拟机就可以上网了。搞不清楚为啥，但结果是成功的。 以后笔记本无论连接哪个网络后，都不用修改虚拟机的 ip 地址了，省事了。 ","date":"2023-10-05","objectID":"/4013e4eb4949/:2:0","tags":["默认标签"],"title":"设置虚拟机静态ip保持不变","uri":"/4013e4eb4949/"},{"categories":["默认分类"],"content":"前段时间偶然看到一篇关于accessToken和refreshToken的讨论帖，了解到了这两个Token的区别，还顺带了解了一些关于OAuth2.0标准的内容，简单记录一下，方便后面复习。本文只是写给我自己看的，因为我也是根据网上的文章自己总结的，可能有误，可以直接去看网上写得更详细的文章 ","date":"2023-10-01","objectID":"/e08af3f827e9/:0:0","tags":["默认标签"],"title":"关于token的一些记录","uri":"/e08af3f827e9/"},{"categories":["默认分类"],"content":"Cookie、Session和Token 参考文章：一文讲透Token与Cookie、Session的区别 为啥会有这几个东西呢，是因为http协议是无状态的协议，两个http请求之间没有联系，假如有很多个http请求，我们该如何区分这些个请求是属于哪个用户的，这就用到了我们提到的Cookie、Session和Token这些东西了。其实Cookie、Session、Token就是一个身份标识，通过这个身份标识，来区分http请求。 Cookie、Session和Token这三者的工作原理、区别、优缺点推荐看我上面参考的那篇文章，写得很好，或者自行百度。 ","date":"2023-10-01","objectID":"/e08af3f827e9/:1:0","tags":["默认标签"],"title":"关于token的一些记录","uri":"/e08af3f827e9/"},{"categories":["默认分类"],"content":"关于Token jwt：jwt只是实现Token的一种方式，你也可以用其他的方式来实现Token。例如对称加密算法或自研的加密算法。 accessToken和refreshToken是为了解决token在实际使用中的一些问题。关于这二者可以参考：Access Token 与 Refresh Token或自行百度 accessToken：一个临时的token，有效时间很短，就是我们用来访问服务器资源所使用的那个token。 refreshToken：用来刷新accessToken的。当accessToken过期或者快要过期的时候，会用refreshToken向服务器获取一个新的accessToken。 为啥要用两个Token呢，这多麻烦啊。我在知乎上看到这个帖子jwt续签为什么要使用双token,没看明白啊，感觉单个token也可以啊?，或许可以解答这个疑惑。 以下是我自己的理解： 1）单独一个Token是可以的（也就是accessToken），token过期后，让用户在重新登录，在给他一个不就好了。这样的话，就需要把token的有效时间设置的长一点，不然用户老是频繁登录很影响使用体验。要避免频繁登录的话，就需要使用到refreshToken了。当accessToken过期后，使用refreshToken重新获取accessToken，将accessToken刷新，这样用户就不用登录了。所以refreshToken的有效时间大于accessToken的有效时间才行。 2）关于安全方面问题，双token这个东西是在OAuth2.0标准中所用到的。*如果只是在用户（客户端）和服务端两者之间使用的话，它并没有安全防护的作用，或者说，它并不是为了解决token安全问题而被使用的，它是为了解决用户频繁登录而被使用的。*但如果是在OAuth2.0标准中，它确实是为了解决安全问题而被使用的，但它不是解决token的安全问题，而是解决安全授权问题，例如我们常用的第三方登录。 ","date":"2023-10-01","objectID":"/e08af3f827e9/:2:0","tags":["默认标签"],"title":"关于token的一些记录","uri":"/e08af3f827e9/"},{"categories":["默认分类"],"content":"关于OAuth 建议自行百度看看什么是OAuth标准，推荐：白话让你理解什么是oAuth2协议和非常详细！深入理解OAuth原理和实践细节两篇文章，写得很好。 画了个简单的图 这个授权流程在OAuth 2中被称为授权码模式（authorization code grant），其命名的原因是，应用程序使用授权码来向授权服务器申请访问令牌/刷新令牌。 有几点需要注意： 1）第三方授权服务器给的token令牌就是：accessToken和refreshToken 2）refreshToken可以获取新的accessToken，所以为了安全，refreshToken一般只在服务器之间使用安全的https进行传递。怎么个意思呢，就是应用APP那里其实是两个部分，一个是APP的客户端（前端），一个是APP的后端，它们之间的请求是APP前端-APP后端-授权服务器，refreshToken自授权服务器传递到APP后端服务器上，就不往APP客户端传了，降低refreshToken被泄露的风险。 OAuth2.0有四种模式，最主要的还是授权码模式，其它三种感觉只是变了变主体，还是同一个思路。理解授权码模式就可以了。 其实整个应用码授权模式还有很多知识没有详细说明，比如3.2中app的认证信息是什么，如何具体实现这个流程，有哪些条件等等，建议看看非常详细！深入理解OAuth原理和实践细节这篇文章，利用第三方github登录详细解释了整个过程，值得一看。我就是看这个明白的。 ","date":"2023-10-01","objectID":"/e08af3f827e9/:3:0","tags":["默认标签"],"title":"关于token的一些记录","uri":"/e08af3f827e9/"},{"categories":["默认分类"],"content":"最后 以上内容比较粗糙，因为我只是记个大概就行，真要详细去学的话还是去看看RFC文档或者其他人的文章吧。 参考文章： https://zhuanlan.zhihu.com/p/625995458 https://www.cnblogs.com/blowing00/p/4524132.html https://www.zhihu.com/question/506320859/answer/2913603859 https://zhuanlan.zhihu.com/p/92051359 https://zhuanlan.zhihu.com/p/380561372 https://www.cnblogs.com/Nyan-Workflow-FC/p/11082590.html ","date":"2023-10-01","objectID":"/e08af3f827e9/:4:0","tags":["默认标签"],"title":"关于token的一些记录","uri":"/e08af3f827e9/"},{"categories":["Linux"],"content":"前言 最近遇到了Linux磁盘扩容的问题，磁盘扩容有好几种情景，因为之前没涉及到，踩了不少坑。在此记录一下，方便后续查阅。 假设有一块磁盘A，容量是100G。我分了20G用来安装Linux系统，剩下的没有动。随着时间的增长，20G不够用了，我可以将磁盘A剩下的80G分给Linux系统，也可以在加装一块磁盘B分给Linux。两种方式都可以实现扩容的目的，但是实现的手段可以分为两种：lvm和非lvm 非lvm方式，就是一般的磁盘挂载，将新硬盘分区并格式化后，挂载到Linux系统的某个文件夹上去，实现磁盘的扩容，但是这种方式一个文件夹只能挂载一个磁盘，如果想要将两块磁盘同时挂载到同一个文件夹上就需要用到lvm进行磁盘管理。 关于什么是lvm可以百度查询。简单来说，lvm可以将多个磁盘视为一个逻辑磁盘。假如有两块磁盘A和磁盘B，使用lvm的话，可以将这两个磁盘看做是一个逻辑磁盘a，我们只需对逻辑磁盘a进行操作，将其挂载到Linux目录下就行，如果后续要增添一块磁盘C，只需要将磁盘C加入逻辑磁盘a就行。以上说法并不准确，但是便于理解。 ","date":"2023-08-12","objectID":"/7f17ea35961e/:1:0","tags":["默认标签"],"title":"linux磁盘扩容","uri":"/7f17ea35961e/"},{"categories":["Linux"],"content":"一点基础知识 简单的磁盘相关命令 df -h # df主要是检查文件系统磁盘占用情况 fdisk -l # fdisk一般用来磁盘分区，也可以用来查看磁盘分区情况。-l,列出所有分区表 lsblk # 用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，这个命令很好用，因为可以让电脑上的磁盘和分区信息很清晰。 lvm相关了解 PV(Physical Volume): 物理卷, 处于LVM最底层, 可以是物理硬盘或者分区; PP(Physical Extend): 物理区域, PV中可以用于分配的最小存储单元, 可以在创建PV的时候指定, 如1M, 2M, 4M, 8M…..组成同一VG中所有PV的PE大小应该相同; VG(Volume Group): 卷组, 建立在PV之上, 可以含有一个到多个PV; LV(Logical Volume): 逻辑卷, 建立在VG之上, 相当于原来分区的概念, 不过大小可以动态改变. ","date":"2023-08-12","objectID":"/7f17ea35961e/:2:0","tags":["默认标签"],"title":"linux磁盘扩容","uri":"/7f17ea35961e/"},{"categories":["Linux"],"content":"使用lvm进行磁盘扩容 参考：https://www.cnblogs.com/lijiaman/p/12885649.html，写的很详细，推荐 注意：在安装Linux系统的时候，有一个配置磁盘分区属性，默认是使用整个磁盘，但是我这里使用的是第二个选项lvm进行的创建。非lvm的磁盘是无法与lvm的磁盘进行逻辑合并的。 ","date":"2023-08-12","objectID":"/7f17ea35961e/:3:0","tags":["默认标签"],"title":"linux磁盘扩容","uri":"/7f17ea35961e/"},{"categories":["Linux"],"content":"使用fdisk进行分区操作 先查看整体磁盘分区情况 sda磁盘在系统安装是采用了lvm，所以才有蓝色框选的两个逻辑卷，否则是没有的。 sdb是未被使用的。将sdb进行分区并格式化 输入fdisk /dev/sdb，回车，然后输入m，回车 输入n并回车，n是“new”新建分区的意思 使用fdisk再次进行查看 磁盘分区之后，磁盘id为83，如果要使用逻辑卷管理，需要将id改为8e，才能创建物理卷。 输入fdisk /dev/sdb，回车，然后输入m，回车，输入t，选择分区1，输入id值8e，输入w保存 最终修改完成 ","date":"2023-08-12","objectID":"/7f17ea35961e/:3:1","tags":["默认标签"],"title":"linux磁盘扩容","uri":"/7f17ea35961e/"},{"categories":["Linux"],"content":"使用lvm进行 先查看当前的一些信息 物理卷 卷组 逻辑卷 将sdb1创建物理卷：pvcreate /dev/sda3 将添加新的物理卷，加载到debian10-vg卷组，使用vgextend debian10-vg /dev/sdb1命令。 将debian10-vg卷组中空闲的5G分给/dev/debian10-vg/root逻辑卷， 使用：lvresize -l 1279 /dev/debian10-vg/root lvresize 命令参数 -L 指定逻辑卷的大小，单位为“kKmMgGtT”字节 -l 指定逻辑卷的大小（LE数） lvresize -L +200M /dev/vg1000/lvol0 #将逻辑卷空间增加200M lvresize -L 5G /dev/vg1000/lvol0 # #将逻辑卷空间变为5G lvresize -l +1000 /dev/vg1000/lvol0 # 安PE数量 默认为+ lvresize -l -1000 /dev/vg1000/lvol0 # 安PE数量 ","date":"2023-08-12","objectID":"/7f17ea35961e/:3:2","tags":["默认标签"],"title":"linux磁盘扩容","uri":"/7f17ea35961e/"},{"categories":["默认分类"],"content":"安装zsh（Debian10） 查看当前 shell：echo $SHELL 查看系统中安装了哪些 shell：cat /etc/shells 切换 shell 环境：chsh -s /bin/zsh 安装：apt install zsh ","date":"2023-07-31","objectID":"/13a9176d44b5/:1:0","tags":["zsh"],"title":"zsh的安装和配置","uri":"/13a9176d44b5/"},{"categories":["默认分类"],"content":"安装 zsh 插件 zsh-autosuggestions：这个是自动建议插件，能够自动提示你需要的命令。根据历史命令提示 zsh-syntax-highlighting：这个是代码高亮插件，能够使你的命令行各个命令清晰明了。 zsh-completions：命令自动补全。感觉不是很好用，看个人情况，不推荐安装。 git clone https://github.com/zsh-users/zsh-autosuggestions /usr/local/zsh-plugins/zsh-autosuggestions # 自动补全 git clone https://github.com/zsh-users/zsh-syntax-highlighting /usr/local/zsh-plugins/zsh-syntax-highlighting # 语法高亮 git clone --depth=1 https://github.com/zsh-users/zsh-completions.git /usr/local/zsh-completions # 命令选项自动补齐，不太好使 # 我fork的仓库，使用ssh连接 git clone git@github.com:BluefoxQAQ/zsh-autosuggestions.git /usr/local/zsh-plugins/zsh-autosuggestions git clone git@github.com:BluefoxQAQ/zsh-syntax-highlighting.git /usr/local/zsh-plugins/zsh-syntax-highlighting git clone git@github.com:BluefoxQAQ/zsh-completions.git /usr/local/zsh-completions ","date":"2023-07-31","objectID":"/13a9176d44b5/:2:0","tags":["zsh"],"title":"zsh的安装和配置","uri":"/13a9176d44b5/"},{"categories":["默认分类"],"content":"zsh的配置 这是我目前正在使用的zsh配置文件，可以直接复制使用 # PS1='[\\[\\e[1;35;1m\\]\\t \\[\\e[1;32;1m\\]\\u@\\H \\[\\e[1;33;1m\\]\\w] \\n \\$ \\[\\e[1;37;1m\\]' # 废弃，不好看 # PS1='\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' # bash用这个 # export PS1=\"%10F%m%f:%11F%1~%f \\$ \" # zsh用这个 # export PS1='%F{#00ffff}%B%n@%m%b%f:%B%F{#00afff}%~%f%#%b ' # zsh用这个 # export PS1=$'%F{#00ffff}%B%n@%m%b%f:%B%F{#00afff}%~%f%b\\n\u003e%# ' # zsh用这个 export PS1=$'%F{#00ffff}%B%n@%m%b%f:%B%F{#00afff}%~%f%b\\n %F{#ffff00}\u003e%#%b%f ' # zsh用这个,双行 alias ls='ls --color' alias grep='grep --color=auto' export GREP_COLOR=\"1;31\" export LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:' # 启用插件 source /usr/local/zsh-plugins/zsh-autosuggestions/zsh-autosuggestions.zsh source /usr/local/zsh-plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh # fpath=(/usr/local/zsh-completions/src $fpath) # 命令选项自动补齐，不用 # autoload -Uz compinit \u0026\u0026 compinit # 启用彩色提示符 autoload -U colors \u0026\u0026 colors # 每次刷新提示符 setopt prompt_subst # 设置提示符 # PROMPT='❰%{$fg[green]%}%n%{$reset_color%}|%{$fg[yellow]%}%1~%{$reset_color%}%{$fg[blue]%}$(git branch --show-current 2\u0026\u003e /dev/null | xargs -I branch echo \"(branch)\")%{$reset_color%}❱ ' # zsh历史命令存储 HISTFILE=\"$HOME/.zsh_history\" HISTSIZE=10000000 SAVEHIST=10000000 setopt BANG_HIST # Treat the '!' character specially during expansion. setopt EXTENDED_HISTORY # Write the history file in the \":start:elapsed;command\" format. setopt INC_APPEND_HISTORY # Write to the history file immediately, not when the shell exits. setopt SHARE_HISTORY # Share history between all sessions. setopt HIST_EXPIRE_DUPS_FIRST # Expire duplicate entries first when trimming history. setopt HIST_IGNORE_DUPS # Don't record an entry that was just recorded again. setopt HIST_IGNORE_ALL_DUPS # Delete old recorded entry if new entry is a duplicate. setopt HIST_FIND_NO_DUPS # Do not display a line previously found. setopt HIST_IGNORE_SPACE # Don't record an entry starting with a space. setopt HIST_SAVE_NO_DUPS # Don't write duplicate entries in the history file. setopt HIST_REDUCE_BLANKS # Remove superfluous blanks before recording entry. setopt HIST_VERIFY # Don't execute immediately upon history expansion. setopt HIST_BEEP # Beep when accessing nonexistent history. # 命令选项自动补齐，不太好使 #_proxy(){ # local cur cword words # 定义变量，cur表示当前光标下的单词 # read -cn cword # 所有指令集 # read -Ac words # 当前指令的索引值 # cur=\"$words[$cword-1]\" # 当前指令值 # if [ $cur = \"proxy\" ] # 根据当前不同指令返回对应的提示信息 # then # reply=(start stop restart connect route help) # 必须是值reply，返回提示信息内容 # elif [ $cur = \"route\" ] # then # reply=(add","date":"2023-07-31","objectID":"/13a9176d44b5/:3:0","tags":["zsh"],"title":"zsh的安装和配置","uri":"/13a9176d44b5/"},{"categories":["默认分类"],"content":"Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。我在学习Swing时遇到了许多困惑，在这里记录一下，以便后续回顾。 ","date":"2023-07-30","objectID":"/e70c6a493b0d/:0:0","tags":["swing"],"title":"java swing学习","uri":"/e70c6a493b0d/"},{"categories":["默认分类"],"content":"JFrame和JPanel详解 刚学习的时候，跟着老师敲，但没有理解这两个东西，导致后面一直搞不清楚Swing的逻辑，查了些资料，现在有点明白了。 举一个不太准确的例子：假设Swing编程就像是我们在画画，我们画的圆圈，方块，文字就相当于Swing中的一个个组件。JFrame相当于一块透明的玻璃板，我们是没有办法在上面直接画画，JPanel相当于一张白纸，把这张白纸放到玻璃板上，就可以在纸上画出圆圈，方块和文字了。 JFrame是不能直接放置组件的，因为JFrame 不是一个容器，它只是一个框架。JFrame 有一个 Content Pane，窗口能显示的所有组件都是添加在这个 Content Pane 中。JFrame 提供了两个方法：getContentPane 和 setContentPane 就是用于获取和设置其 Content Pane 的。 先说setContentPane方法，常见于这样写：建立一个Jpanel中间容器，把组件添加到容器中，用setContentPane方法把该容器置为JFrame的内容面板 public class MyFrame3 extends JFrame { public MyFrame3(String tittle) { super(tittle); //创建一个面板，作为容器绑定到窗口上，这是不可见的 JPanel jPanel = new JPanel(); this.setContentPane(jPanel); JButton button = new JButton(\"按钮\"); jPanel.add(button); this.setVisible(true); // 设置可见 } } 再说说getContentPane方法，常见于这样写：不用建立中间容器，直接用getContentPane().add()方式添加组件。getContentPane是得到了jframe的内容面板。 public class TestFrame extends JFrame{ public TestFrame() { JLabel label = new JLabel(\"lableTest\"); getContentPane().add(label); add(label); // 效果同上 } } 注意：在1.5版本之后，可以不用getContentPane，直接使用add方法即可。 ","date":"2023-07-30","objectID":"/e70c6a493b0d/:1:0","tags":["swing"],"title":"java swing学习","uri":"/e70c6a493b0d/"},{"categories":["默认分类"],"content":"容器和组件 容器：JFrame（窗体），JDialog（对话框），JPanel（面板） 顶级容器：也称窗口。JFrame 和 JDialog 是最为常用也是最为简单的顶级容器 中间容器：也称面板组件。常见有：JPanel和JScrollPane（带滚动条的面板）。不常见的：JInternalFrame和JRootPane(可以直接从顶层容器中获得) 组件：button，label等 总结梳理： 在Swing中，任何其他组件都必须位于一个顶层容器中（如JFrame）。中间容器是为了容纳其他组件而存在的，它能容纳组件并将组件组合在一起，但它本身必须添加到其他容器中使用。 ","date":"2023-07-30","objectID":"/e70c6a493b0d/:2:0","tags":["swing"],"title":"java swing学习","uri":"/e70c6a493b0d/"},{"categories":["默认分类"],"content":"组件使用 JMenuBar：顶部菜单栏 JTabbedPane：选项卡面板 ","date":"2023-07-30","objectID":"/e70c6a493b0d/:3:0","tags":["swing"],"title":"java swing学习","uri":"/e70c6a493b0d/"},{"categories":["默认分类"],"content":"布局管理器 注意：JFrame和JDialog默认布局为BorderLayout，JPanel和Applet默认布局为FlowLayout 参考：https://www.cnblogs.com/meteor119/p/15218920.html 流式布局：FlowLayout 边界布局：BorderLayout 网格布局：GridLayout 空布局/绝对布局：null ","date":"2023-07-30","objectID":"/e70c6a493b0d/:4:0","tags":["swing"],"title":"java swing学习","uri":"/e70c6a493b0d/"},{"categories":["docker"],"content":"Docker 安装 下载： https://docs.docker.com/get-docker/ ","date":"2023-07-30","objectID":"/c39e4bf43084/:1:0","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"Win 10（家庭版） 需要安装Hyper-V才可以。将如下代码添加到记事本中，并另存为 Hyper-V.cmd 文件。右键以管理员身份运行，然后等待安装，最后输入 Y 进行重启即可 pushd \"%~dp0\" dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum \u003ehyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^\u003enul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 重启完后双击 docker 安装包安装，再次重启，启动 docker，可能提示 wsl 版本低，wsl --update ","date":"2023-07-30","objectID":"/c39e4bf43084/:1:1","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"Win 10 (专业版) 启用Hyper-V进行安装：在控制面板—启用或关闭 Windows 功能，勾选Hyper-V和容器两个选项，两个都要，不然报错。然后重启，双击 exe 文件。 注意：如果使用安卓虚拟机的话，二者会有冲突。安卓虚拟机需要关闭 Hyper-V，docker 需要开启 Hyper-V。有文章说在控制面板—启用或关闭 Windows 功能—启用 Windows 虚拟机监控程序平台，勾选这个可以解决冲突，但我试了没有用。我用夜神模拟器有冲突，改用蓝叠 4 模拟器（hyper-v）版本 配置阿里云镜像： https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 修改默认位置：默认是在 C 盘 打开设置，选择存储位置 之前眼瞎没找见设置里的 Disk image location 选项，找了另一篇文章里的方法。 C:\\Users\\\u003e wsl --list -v # 退出docker，用任务管理器杀进程 NAME STATE VERSION * docker-desktop Stopped 2 docker-desktop-data Stopped 2 C:\\Users\\\u003e wsl --export docker-desktop-data \"D:\\\\docker-desktop-data.tar\" # 将docker-desktop-data导出到文件中(备份image及相关文件) 正在导出，这可能需要几分钟时间。 操作成功完成。 C:\\Users\\\u003e wsl --unregister docker-desktop-data # 从wsl取消注册docker-desktop-data 正在注销。 操作成功完成。 C:\\Users\\\u003e wsl --import docker-desktop-data \"E:\\\\DockerImage\\\\wsl\" \"D:\\\\docker-desktop-data.tar\" --version 2 # 将导出的docker-desktop-data再导入回wsl，并设置我们想要的路径，即新的镜像及各种docker使用的文件的挂载目录，我这里设置到E:\\\\DockerImage\\\\wsl 参考： https://blog.csdn.net/u013948858/article/details/111464534 ","date":"2023-07-30","objectID":"/c39e4bf43084/:1:2","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"Debian 10 安装 Docker 1）直接使用脚本安装： curl -sSL https://get.docker.com/ | sh # 使用阿里镜像源 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 2）执行以下步骤从 Docker 的存储库安装最新的稳定 Docker 版本。root 用户下执行 apt update # 安装通过 HTTPS 添加新存储库所需的软件包： apt install apt-transport-https ca-certificates curl software-properties-common gnupg2 # 使用以下 curl 命令导入存储库的 GPG 密钥；成功后，命令将返回 OK 。 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - # 将稳定的 Docker APT 存储库添加到系统的软件存储库列表中： add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable\" # 更新 apt 软件包列表并安装最新版本的 Docker CE (Community Edition) apt update apt install docker-ce 3）离线安装 因网络问题，导致 docker 无法联网安装，所以使用离线安装的方式。直接参考这个文章： https://blog.csdn.net/weixin_42571882/article/details/134015815 下载 docker 安装包： https://download.docker.com/linux/static/stable/x86_64/ ，网盘下载：docker-25.0.5.tgz # 注意从网盘下载的文件后缀名为docker-25.0.5.tgz.zip，需要先改为docker-25.0.5.tgz mv docker-25.0.5.tgz.zip docker-25.0.5.tgz # 改后缀 tar -zxvf docker-25.0.5.tgz # 解压docker安装包 cp docker/* /usr/bin/ # 将解压后的文件复制到/usr/bin/目录下 赋予文件执行权限 # 赋予文件执行权限，可以先赋予，在复制到/usr/bin/目录下 chmod +x /usr/bin/docker* 查看是否有执行权限 ls -l /usr/bin/docker* 将 docker 注册成系统服务 vim /etc/systemd/system/docker.service 添加如下内容，然后保存退出（我也不知道这些内容的具体含义，反正目前用着没问题） [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/bin/dockerd ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=infinity LimitNPROC=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target 赋予文件执行权限 chmod +x /etc/systemd/system/docker.service systemctl daemon-reload systemctl start docker 修改 docker 的存储路径 方法一：使用软连接(个人常用) # 查看现在的存储路径，默认是 /var/lib/docker docker info | grep \"Root Dir # 将这个目录复制到/opt目录下，名字任意 cp -r /var/lib/docker /opt/docker_images # 删除原来的目录 rm -r /var/lib/docker # 创建软链接 ln -s /opt/docker_images /var/lib/docker # 记得重启docker或系统 方法二：修改配置文件 因为我这里没有 /etc/docker/daemon.json 这个文件，遂放弃。 安装 docker-compose # 从github下载docker-compose二进制文件，这可能需要一段时间 curl -L \"https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose # 给予运行权限 chmod +x /usr/local/bin/docker-compose # 查看安装版本 docker-compose -v ","date":"2023-07-30","objectID":"/c39e4bf43084/:1:3","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"Docker 命令 参考：Docker 命令大全|菜鸟教程 ","date":"2023-07-30","objectID":"/c39e4bf43084/:2:0","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"镜像仓库 login/logout docker login -u 用户名 -p 密码 # 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub docker logout # 登出Docker Hub search 参数说明： NAME: 镜像仓库源的名称 DESCRIPTION: 镜像的描述 OFFICIAL: 是否 docker 官方发布 stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。 AUTOMATED: 自动构建。 --automated :只列出 automated build类型的镜像； --no-trunc :显示完整的镜像DESCRIPTION(描述)，不省略； -f \u003c过滤条件\u003e:列出收藏数(点赞)不小于指定值的镜像。 --limit 5:列出前5个镜像 build docker build：用于使用 Dockerfile 创建镜像 –tag，-t：镜像的名字及标签 -f：指定要使用的 Dockerfile 路径 docker build -t bluelotus_xss_docker:2.0 . 注意：最后要加路径，这里最后有个空格和点，代表上下文路径。 pull 语法：docker pull [OPTIONS] NAME[:TAG|@DIGEST] OPTIONS 选项： –all-tags, -a： 用于下载该存储库中具有不同标签的所有镜像。 –disable-content-trust： 它会在拉取之前跳过镜像验证。 –platform： 用于设置平台。 –quiet, -q： 用于静默拉取镜像（不冗长）。 –help： 了解更多有关命令的信息 docker pull citizenstig/dvwa # 默认tag是:latest，更多tag需要再hub中查看 docker pull mysql:5.7 docker pull centos:centos6.8 push 注意：发布镜像时，需要将 image 重新命名，命名格式应为: dockerhub 用户名/镜像名 docker tag bluelotus_xss_docker:1.0 bluefoxqaq/bluelotus_xss_docker:1.0 docker login -u admin -p 123456 docker push bluefoxqaq/bluelotus_xss_docker:1.0 ","date":"2023-07-30","objectID":"/c39e4bf43084/:2:1","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"本地镜像管理 images docker images：列出本地镜像。 语法：docker images [OPTIONS] [REPOSITORY[: TAG]] OPTIONS 说明： -a : 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）； –digests : 显示镜像的摘要信息； -f : 显示满足条件的镜像； –format : 指定返回值的模板文件； –no-trunc : 显示完整的镜像信息； -q : 只显示镜像 ID。 rmi docker rmi : 删除本地一个或多个镜像。 语法：docker rmi [OPTIONS] IMAGE [IMAGE…] OPTIONS 说明： -f : 强制删除 –no-prune : 不移除该镜像的过程镜像，默认移除 例如：docker rmi -f runoob/ubuntu:v4 tag docker tag：为本地镜像添加一个新的标签 docker tag bluelotus_xss_docker:1.0 bluefoxqaq/bluelotus_xss_docker:1.0 注意：它们是同一个镜像，只是别名不同而已。 inspect docker inspect：获取镜像的详细信息，其中，包括创建者，各层的数字摘要等。 -f ，–format：指定返回值的模板文件。Go 模板格式化输出 docker inspect debian:12.5 # 查看镜像的操作系统架构（arm还是x86） docker inspect --format='{{.Os}}/{{.Architecture}}' e6bce4a855e5 # 获取正在运行的容器dvwa的 IP docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' dvwa save docker save：将指定镜像保存成 tar 归档文件。 -o ：输出到的文件。 # 例如 docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3 docker save -o xss_platfrom_docker.tar 79bb31b88efb load docker load：导入使用 docker save 命令导出的镜像。 -i：指定导入的文件 -q：精简输出信息 docker load -i xss_platfrom_docker.tar export 和 import 导出的是一个容器的快照, 不是镜像本身, 也就是说没有 layer。你的 dockerfile 里的 workdir, entrypoint 之类的所有东西都会丢失，commit 过的话也会丢失。快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。 docker save 保存的是镜像（image），docker export 保存的是容器（container）；docker load 用来载入镜像包，docker import 用来载入容器包，但两者都会恢复为镜像；docker load 不能对载入的镜像重命名，而 docker import 可以为镜像指定新名称。 ","date":"2023-07-30","objectID":"/c39e4bf43084/:2:2","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"容器操作 ps docker ps : 列出容器 -a : 显示所有的容器，包括未运行的。 -f : 根据条件过滤显示的内容。 –format : 指定返回值的模板文件。 -l : 显示最近创建的容器。 -n : 列出最近创建的 n 个容器。 –no-trunc : 不截断输出。 -q : 静默模式，只显示容器编号。 -s : 显示总的文件大小。 run docker run ： 创建一个新的容器并运行一个命令 -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器 ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机 (宿主)端口: 容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=“nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的 DNS 服务器，默认和宿主一致； –dns-search example. com: 指定容器 DNS 搜索域名，默认和宿主一致； -h “mars”: 指定容器的 hostname； -e username=“ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=“0-2” or –cpuset=“0,1,2”: 绑定容器到指定 CPU 运行； -m : 设置容器使用内存最大值； –network=“bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； **–link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 start/stop/restart docker start：启动一个或多个已经被停止的容器 docker stop：停止一个运行中的容器 docker restart：重启容器 exec docker exec ：在运行的容器中执行命令 -d : 分离模式: 在后台运行 -i : 即使没有附加也保持 STDIN 打开 -t : 分配一个伪终端 例如： $ docker exec -i -t mynginx /bin/bash // 在容器 mynginx 中开启一个交互模式的终端 $ docker exec -it 9df70f9a0714 /bin/bash // 9df70f9a0714 是容器 id $ docker exec 9df70f9a0714 service nginx strart cp docker cp : 用于容器与主机之间的数据拷贝。 语法：docker cp [OPTIONS] srcPath destPath 例如： 将主机/ www/runoob目录拷贝到容器 96f7f14e99ab 的/ www目录下 。 docker cp / www/runoob 96f7f14e99ab:/www/ 将主机/ www/runoob目录拷贝到容器 96f7f14e99ab 中，目录重命名为 www 。 docker cp / www/runoob 96f7f14e99ab:/www 将容器 96f7f14e99ab 的/ www目录拷贝到主机的/tmp目录中 。 docker cp 96f7f14e99ab:/ www /tmp/ rm docker rm：删除一个或多个容器。 强制删除容器 db01、db02：docker rm -f db01 db02 update docker update：更新一个或多个容器的配置 docker update --restart=always 容器 ID (或者容器名) # 容器开机自启 rename 将容器重命名 docker rename 原容器名称新容器名称 logs docker logs : 获取容器的日志 –since：显示某个开始时间的所有日志 -t：显示时间戳 –tail：仅列出最新 N 条容器日志 # 查看某时间之后最新的 100 条日志： docker logs -t --since=\"2021-08-18T11:46:37\" --tail=100 CONTAINER_ID） ","date":"2023-07-30","objectID":"/c39e4bf43084/:2:3","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"网络管理 docker network create：创建一个 docker 局域网络 docker network create mynetwork docker network create --subnet 172.16.7.0/24 mynetwork # 指定网段 docker network connnet：将某个容器连接到一个 docker 网络 docker network connect mynetwork nginx docker network connect mynetwork 镜像 id # 在 docker run 时配置网络信息 docker run --name mynginx --network mynetwork --network-alias nginx --ip 172.16.7.2 xxxxxxxx # --network ：加入 docker 内部网络 # --network-alias ：配置容器在内部局域网的网络别名 # --ip：配置在内部局域网的 ip 地址 172.172.0.1 是网关 # 一个名为 mynginx 的容器，加入到 mynetwork 的网络当中，他的网络名为 nginx。 # 启动 Docker 容器的时候，使用默认的网络是不支持指派固定 IP 的 docker network disconnect：将某个容器退出某个局域网络 docker network ls：显示所有 docker 局域网络 docker network inspect：显示某个局域网络信息 docker network rm：删除 docker 网络 docker network prune：删除所有未引用的 docker 局域网络 ","date":"2023-07-30","objectID":"/c39e4bf43084/:2:4","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"Docker-Compose Docker-Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。 ","date":"2023-07-30","objectID":"/c39e4bf43084/:3:0","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"安装 # 从 github 下载 docker-compose 二进制文件，这可能需要一段时间 curl -SL https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose # 给予运行权限 chmod +x /usr/local/bin/docker-compose # 查看安装版本 docker-compose -v ","date":"2023-07-30","objectID":"/c39e4bf43084/:3:1","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["docker"],"content":"简单使用 docker-compose up ：该命令可以自动完成包括构建镜像，(重新)创建服务，启动服务，并关联服务相关容器的一系列操作。 默认情况下，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。当通过 Ctrl+c 停止命令时，所有容器将会停止。如果希望在后台启动并运行所有的容器，使用 docker-compose up -d。 docker-compose ps ：列出项目中目前的所有容器 docker-compose pull ：拉取服务依赖的镜像 docker-compose restart ：重启项目中的服务 docker-compose start ：启动已经存在的服务容器。 docker-compose stop ：停止正在运行的容器，可以通过 docker-compose start 再次启动 docker-compose rm ：删除所有（停止状态的）服务容器。选项包括： –f, –force，强制直接删除，包括非停止状态的容器 -v，删除容器所挂载的数据卷 stop 是只停掉容器不删除；down 是停掉容器然后删除掉二者区别 ","date":"2023-07-30","objectID":"/c39e4bf43084/:3:2","tags":["docker"],"title":"docker使用","uri":"/c39e4bf43084/"},{"categories":["默认分类"],"content":"安装部署 安装NodeJs：https://nodejs.org/en/download 安装Git：https://git-scm.com/download/win 安装hexo，输入以下命令 npm install hexo-cli -g # 安装hexo脚手架 hexo init blog # blog是自定义文件夹名字 cd blog hexo server # 启动hexo 注意：网络问题可能有点慢。 安装插件（看个人情况安装） npm install hexo-renderer-pug hexo-renderer-stylus --save # 必须安装，不然无法运行，会报错 npm install https://github.com/BluefoxQAQ/hexo-asset-image.git --save # 插入图片用的插件 npm install hexo-generator-search --save # 安装搜索插件 # 主题使用本地静态js，cdn配置相关，可选。需要和主题版本最新，否则可能报错。见下文butterfly主题配置cdn npm install hexo-butterfly-extjs --save npm install hexo-deployer-git --save # 安装github部署插件 npm install hexo-deployer-ftpsync --save # 安装FTP部署插件 npm install https://github.com/BluefoxQAQ/hexo-deployer-ali-oss.git --save # 阿里云OSS一键部署插件 安装butterfly主题：在根目录运行命令 git clone -b master https://gitee.com/immyw/hexo-theme-butterfly.git themes/butterfly 官方文档：https://butterfly.js.org/posts/21cfbf15/ ","date":"2023-07-23","objectID":"/443889da05ee/:1:0","tags":["blog"],"title":"博客网站搭建","uri":"/443889da05ee/"},{"categories":["默认分类"],"content":"hexo简单命令 hexo new \"文章名字\" # 新建文章 hexo new post -p /后端/test.md # 在指定目录下新建文章 hexo new page \"页面名字\" # 新建页面 hexo generate # 生成静态页面至public目录 hexo server # 开启预览访问端口（默认端口4000，'ctrl + c'关闭server） hexo s -p 5000 # 更换端口 hexo deploy # 上传部署，大部分人是部署到GitHub，需要配置 hexo clean # 清除缓存 hexo help # 查看帮助 hexo version # 查看Hexo的版本 缩写命令： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy ","date":"2023-07-23","objectID":"/443889da05ee/:2:0","tags":["blog"],"title":"博客网站搭建","uri":"/443889da05ee/"},{"categories":["默认分类"],"content":"配置文件 ","date":"2023-07-23","objectID":"/443889da05ee/:3:0","tags":["blog"],"title":"博客网站搭建","uri":"/443889da05ee/"},{"categories":["默认分类"],"content":"hexo配置 # Site title: 蓝狐狸 subtitle: Hello and welcome description: '我很懒' keywords: author: 蓝狐狸 language: zh-CN timezone: '' # 设置URL url: https://www.lanhuli.top # 自定义文章链接，这里使用hash值 permalink: :hash.html # 资源文件夹，创建文章时自动创建同名文件夹 post_asset_folder: true # 更换主题 theme: butterfly 使用ftp上传 deploy: type: ftpsync #上传方式，固定ftpsync host: xxx.xxx.xxx.xxx #ftp地址 user: **** #帐号 pass: **** #密码 remote: /webroot #上传至哪个目录 port: 21 #端口 ","date":"2023-07-23","objectID":"/443889da05ee/:3:1","tags":["blog"],"title":"博客网站搭建","uri":"/443889da05ee/"},{"categories":["默认分类"],"content":"butterfly主题配置 顶部导航栏 menu: 首页: / || fas fa-home # 具体分类||fas fa-archive: # web: /categories/web前端/ || fas fa-music 标签: /tags/ || fas fa-tags 分类: /categories/ || fas fa-folder-open # List||fas fa-list: # Music: /music/ || fas fa-music # Movie: /movies/ || fas fa-video # Link: /link/ || fas fa-link 关于: /about/ || fas fa-heart 代码块：只修改样式为mac，其它默认即可 highlight_theme: mac 网站图标：默认使用的是butterfly主题的图标，在\\blog\\themes\\butterfly\\source\\img目录下 # Favicon（網站圖標） favicon: /img/favicon.png 头像设置 avatar: img: /img/avatar.jpg # 自定义图片 effect: false # 不开启旋转 主页背景图片： # The banner image of home page index_img: /img/background.png 主页侧边栏设置(aside) # aside (側邊欄) # -------------------------------------- aside: enable: true hide: false button: true mobile: true # display on mobile position: right # left or right，显示在右边 display: archive: true tag: true category: true card_author: enable: true description: button: enable: false # 默认true，不喜欢，改为false icon: fab fa-github text: Follow Me link: https://github.com/xxxxxx card_announcement: enable: true content: 随便写写，随缘更新。 card_recent_post: enable: true # 最新文章 limit: 5 # if set 0 will show all sort: date # date or updated sort_order: # Don't modify the setting unless you know how it works card_categories: enable: false # 显示所有分类 limit: 8 # if set 0 will show all expand: none # none/true/false sort_order: # Don't modify the setting unless you know how it works card_tags: enable: false # 显示所有标签 limit: 40 # if set 0 will show all color: false orderby: random # Order of tags, random/name/length order: 1 # Sort of order. 1, asc for ascending; -1, desc for descending sort_order: # Don't modify the setting unless you know how it works card_archives: enable: false # 显示归档 type: monthly # yearly or monthly format: MMMM YYYY # eg: YYYY年MM月 order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending limit: 8 # if set 0 will show all sort_order: # Don't modify the setting unless you know how it works card_webinfo: enable: false # 显示网站咨询 post_count: true last_push_date: true sort_order: # Don't modify the setting unless you know how it works card_post_series: enable: true # 排序 orderBy: 'date' # Order by title or date order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending 顶部图片：直接透明化 # If the banner of page not setting, it will show the top_img default_top_img: Transparent 404页面 error_404: enable: true # 开启主题自带的404页面 subtitle: 'Page Not Found' background: https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png 文章目录设置 # toc (目錄) toc: post: true # 文章页是否显示 TOC page: false # 普通页面是否显示 TOC number: true # 是否显示章节数 expand: true # 是否展开 TOC style_simple: true # for post 简洁模式（侧边栏只显示 TOC, 只对文章页有效 ） scroll_percent: true # 是否显示滚动进度百分比 文章过期提醒：以更新时间为基准 # Displays outdated notice for a post (文章過期提醒) noticeOutdate: enable: true style: flat # style: simple/flat limit_day: 365 # When will it be shown position: top # position: top/bottom message_prev: 这篇文章距离更新已经过了 message_next: 天，其中某些内容可能已经过时了。 # 这篇文章距离更新已经过了 365 天，其中某些内容可能已经过时了。 文章分享 # 注意：只能二选一 # Share.js # https://github.com/overtrue/share.js sharejs: enable: true # 默认true，不喜欢分享，可以设置为false sites: facebook,twitter,wechat,weibo,qq # AddToAny # https://www.addtoany.com/ addtoany: enable: false # 同上 item: facebook,twitter,wechat,sina_weibo,facebook_messenger,email,copy_link 设置网站背景 background: url(/img/background.png) # 完美 footer_bg: Transparent 动态彩带背景：没开启 # Fluttering Ribbon (動態彩帶) canvas_fluttering_ribbon: enable: false mobile: false 鼠标点击特效：看你喜欢哪个，我用的烟火特效 fireworks: enable: true zIndex: 9999 # -1 or 9999 mobile: false 页面美化：没开启，个人觉得不开也挺好的。 # Beautify (美化頁面顯示) beautify: enable: false field: post # site/post title-prefix-icon: # '\\f0c1' title-prefix-icon-color: # '#F47466' 全局字体设置 # Global font settings # Don't modify the following settings unless you know how they work (非必要不要修改) font: global-font-size: code-font-size: font-family: Microsoft YaHei code-font-family: consolas 主页 subtitle # the subtitle on homepage (主頁subtitle) subtitle: enable: true # Typewriter Effect (打字效果) effect: true # Cu","date":"2023-07-23","objectID":"/443889da05ee/:3:2","tags":["blog"],"title":"博客网站搭建","uri":"/443889da05ee/"},{"categories":["默认分类"],"content":"多端同步问题 在多台电脑上编辑博客内容，可以用git分支进行同步，但是个人觉得每次都要pull和push有点麻烦。我个人使用坚果云同步source目录，配置文件和模板文件上传云盘，至于hexo环境和主题只需要在开始安装一次就行。 当我更换新电脑时，重新安装hexo环境、主题、插件，把配置文件从云盘下载到根目录，在用坚果云将source目录同步过来就行了。这样，不管在哪一台电脑上编辑文章，坚果云会自动帮我同步至最新。 ","date":"2023-07-23","objectID":"/443889da05ee/:4:0","tags":["blog"],"title":"博客网站搭建","uri":"/443889da05ee/"},{"categories":["默认分类"],"content":"npm命令 查看全局安装的包：npm ls -g 查看当前项目安装的包：npm ls ","date":"2023-07-23","objectID":"/443889da05ee/:5:0","tags":["blog"],"title":"博客网站搭建","uri":"/443889da05ee/"},{"categories":["默认分类"],"content":"生成github的ssh秘钥 ssh-keygen -t rsa cat id_rsa.pub ","date":"2023-07-23","objectID":"/443889da05ee/:6:0","tags":["blog"],"title":"博客网站搭建","uri":"/443889da05ee/"},{"categories":["安全工具"],"content":"1. 下载安装 下载地址： https://github.com/maurosoria/dirsearch 进入下载解压后的目录中，打开cmd，运行安装脚本 python setup.py install 运行如下命令安装用到的python库，可能需要先升级pip pip3 install -r requirements.txt ","date":"2023-01-23","objectID":"/ad81d17c7375/:1:0","tags":["dirsearch"],"title":"dirsearch使用","uri":"/ad81d17c7375/"},{"categories":["安全工具"],"content":"2. 目录结构 其中，db文件夹为自带字典文件夹；reports为扫描日志文件夹；dirsearch.py为主程序文件 ； 安装完成后将目录地址改为主程序解压地址，使用管理员cmd启动dirsearch。 ","date":"2023-01-23","objectID":"/ad81d17c7375/:2:0","tags":["dirsearch"],"title":"dirsearch使用","uri":"/ad81d17c7375/"},{"categories":["安全工具"],"content":"3. 常用命令参数 注意：在做扫描时太快会扫不出来 格式： python dirsearch.py 参数 常用参数列表： -c：指定cookie扫描 dirsearch -u http://127.0.0.1 -c “user=Mo60;” -e：指定需要扫描的文件名 例如：-e php 如果不知道即所有 -e * dirsearch -u http://127.0.0.1 -e jsp -s：每一秒扫描一次 dirsearch -u http://127.0.0.1 -s 1 -t：指定线程数（默认为10）（如果扫不出来就把线程弄的越低越好0.5也可以） dirsearch -u http://127.0.0.1 -t 2 -w：指定自定义的字典文件路径 dirsearch -u http://127.0.0.1 -w /root/php.txt -x：排除的响应状态码(以逗号分隔,支持指定范围) 如(-x 301,500-599) -i：保留的响应状态码(以逗号分隔,支持指定范围) 如(-i 200,300-399) –random-agents：使用随机ua头 dirsearch -u http://127.0.0.1 –random-agents -r：递归扫描 dirsearch -u http://127.0.0.1 -r 3 输出参数： -o FILE, –output=FILE 输出文件的文件地址 –format=FORMAT Report format (Available: simple, plain, json, xml, md, csv, html) simple：简单输出文件，只找到路径 plain：纯文本输出文件，找到带有状态代码的路径 例如：python dirsearch.py -u http://192.168.56.101/pikachu -e php --format=simple -o D:\\11.txt ","date":"2023-01-23","objectID":"/ad81d17c7375/:3:0","tags":["dirsearch"],"title":"dirsearch使用","uri":"/ad81d17c7375/"}]